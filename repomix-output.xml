This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .wrangler, **/*.yaml, src/customTypes/Api.ts, .dev.vars, **/mockData
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    playwright.yml
public/
  fonts/
    montserrat/
      Montserrat-Bold.woff
      Montserrat-Bold.woff2
      Montserrat-Regular.woff
      Montserrat-Regular.woff2
  icons/
    android-chrome-192x192.png
    android-chrome-384x384.png
    apple-touch-icon.png
    browserconfig.xml
    Dot_logo.svg
    favicon-16x16.png
    favicon-32x32.png
    favicon.ico
    mstile-150x150.png
    safari-pinned-tab.svg
    site.webmanifest
  images/
    Benin-example.jpg
  _headers
src/
  components/
    DownloadForm/
      DownloadRadio.tsx
      DownloadSelect.tsx
      DownloadSwitch.tsx
      HiddenForm.tsx
    Player/
      ChapterMarker.tsx
      SeekBarText.tsx
    PlayerNavigation/
      ChapterButton.tsx
      ChaptersList.tsx
      DownloadMenu.tsx
    AppWrapper.tsx
    Header.tsx
    Heading.tsx
    I18nWrapper.tsx
    Icons.tsx
    Player.tsx
  customTypes/
    types.ts
  i18n/
    en.ts
    fr.ts
    index.ts
  images/
    dotLogos/
      DOT_logo_plain.webp
      DOT_logo.webp
      Just DOT.webp
      Just_DOT_no background.webp
      No_background_plain.webp
      No_background.webp
    Benin-example.jpg
  layouts/
    Layout.astro
  lib/
    routes.ts
    store.ts
    UI.tsx
    utils.ts
  licenses/
    another.md
    benin.md
    brazil.md
    bukavu.md
    cameroon.md
    congoFrench.md
    cotdivoir.md
    ghana.md
    malawi.md
    malayalam.md
    marathi.md
    paraguay.md
    tanzania.md
    togo.md
  pages/
    [bookChap]/
      index.astro
    api/
      getId.ts
      getPlaylist.ts
    404.astro
    index.astro
    license.astro
  constants.ts
  domainConfig.ts
  env.d.ts
  global.css
  pwa.ts
  sw.ts
tests/
  e2e/
    download-simple.spec.ts
    download.spec.ts
    navigation.spec.ts
    page-load.spec.ts
    responsive.spec.ts
    theme-toggle.spec.ts
    video-playback.spec.ts
  fixtures/
    test-helpers.ts
  handlers.ts
  setup.ts
.eslintrc.cjs
.gitignore
AGENTS.md
astro.config.mjs
package.json
playwright.config.ts
README.md
tsconfig.json
uno.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/icons/browserconfig.xml">
<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square150x150logo src="/mstile-150x150.png"/>
            <TileColor>#da532c</TileColor>
        </tile>
    </msapplication>
</browserconfig>
</file>

<file path="public/icons/safari-pinned-tab.svg">
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="400.000000pt" height="400.000000pt" viewBox="0 0 400.000000 400.000000"
 preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.14, written by Peter Selinger 2001-2017
</metadata>
<g transform="translate(0.000000,400.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path d="M1248 3490 c-43 -13 -96 -49 -118 -79 -18 -26 -24 -28 -87 -28 -93 1
-166 -40 -203 -114 -20 -38 -22 -39 -73 -39 -89 -1 -161 -44 -205 -125 -15
-27 -17 -98 -18 -733 0 -386 3 -731 7 -765 20 -169 130 -362 266 -468 110 -87
193 -125 335 -153 88 -18 248 -13 317 9 13 4 19 -5 29 -42 30 -111 121 -180
228 -171 54 5 56 4 85 -33 53 -68 157 -100 234 -73 39 13 41 13 75 -20 55 -52
87 -67 148 -71 108 -8 107 -8 633 517 262 261 495 499 518 528 73 92 131 226
149 340 12 76 6 211 -12 291 -57 257 -268 475 -528 546 -46 13 -100 18 -203
17 -126 0 -148 -3 -220 -28 -156 -53 -224 -102 -420 -303 -60 -62 -112 -113
-115 -113 -3 0 -13 21 -22 48 -20 56 -81 118 -134 137 -27 10 -87 14 -199 13
-88 0 -166 0 -173 1 -10 1 -12 80 -11 374 2 414 1 415 -66 478 -61 58 -145 81
-217 59z m130 -100 c18 -11 41 -34 52 -52 19 -31 20 -51 20 -395 0 -283 -3
-363 -12 -364 -58 -3 -117 -9 -144 -13 l-32 -6 1 318 c1 280 -1 323 -16 364
-10 25 -27 54 -37 63 -24 22 -25 41 -5 61 46 46 119 56 173 24z m-270 -110
c18 -11 41 -34 52 -52 18 -30 19 -50 17 -362 l-2 -331 -62 -41 c-35 -22 -73
-50 -86 -62 -13 -12 -26 -22 -30 -22 -4 0 -7 142 -7 316 0 348 -3 370 -57 434
-30 35 -33 42 -22 62 39 73 129 99 197 58z m-281 -151 c46 -22 74 -62 79 -114
1 -16 3 -226 4 -465 l1 -435 39 80 c69 141 186 239 335 283 59 17 527 26 585
11 45 -11 97 -61 105 -100 10 -43 -1 -90 -29 -121 -43 -51 -71 -56 -312 -56
-122 0 -240 -3 -262 -7 -60 -10 -126 -56 -159 -112 -25 -43 -28 -59 -32 -156
-5 -153 4 -207 43 -264 87 -127 277 -139 377 -25 54 61 61 92 64 257 2 165 11
197 62 233 28 19 83 37 83 27 0 -3 -9 -24 -21 -46 -25 -49 -27 -128 -5 -180 8
-20 49 -72 91 -115 l76 -79 -6 -70 c-6 -82 -13 -123 -24 -143 -5 -8 -94 -101
-198 -206 -105 -105 -197 -201 -205 -214 -32 -47 -215 -72 -349 -46 -136 26
-261 93 -357 193 -55 56 -142 192 -142 221 0 9 -4 20 -9 26 -5 5 -12 29 -16
54 -4 24 -9 49 -13 54 -8 15 -10 1384 -1 1424 9 40 42 79 84 98 42 18 62 17
112 -7z m2208 -413 c421 -143 589 -618 350 -991 -41 -65 -1006 -1031 -1045
-1047 -78 -32 -173 18 -193 103 -15 62 1 83 338 423 180 180 325 330 322 332
-2 2 -21 -5 -43 -15 -68 -32 -141 -44 -238 -38 -102 5 -174 28 -252 80 -49 32
-376 351 -407 397 -23 33 -21 98 2 136 22 37 97 76 132 70 13 -3 30 -5 37 -5
8 -1 98 -83 200 -184 206 -202 229 -217 333 -212 78 3 119 27 214 120 97 97
115 128 122 212 13 151 -100 267 -253 258 -73 -4 -126 -35 -228 -136 -50 -49
-100 -95 -111 -102 -35 -24 -78 -27 -120 -8 -51 23 -75 50 -85 96 -15 68 2 97
143 238 73 73 150 146 172 164 64 49 165 99 235 117 98 24 98 24 200 21 72 -2
114 -9 175 -29z m-286 -462 c71 -42 102 -135 68 -201 -25 -47 -175 -191 -213
-203 -37 -12 -78 -9 -115 10 -26 13 -169 150 -169 162 0 3 10 10 23 14 12 3
70 54 128 111 136 133 195 156 278 107z m-1146 -130 c3 -4 1 -16 -5 -28 -7
-13 -12 -81 -13 -171 -1 -117 -5 -157 -18 -181 -64 -123 -227 -124 -285 -1
-17 36 -20 60 -18 159 2 106 4 119 28 155 39 60 75 73 199 73 58 0 109 -3 112
-6z m556 -577 c25 -23 57 -49 71 -58 l24 -16 -225 -224 c-124 -123 -233 -238
-242 -254 -8 -17 -18 -51 -22 -75 -9 -58 -10 -60 -49 -60 -42 0 -110 44 -129
84 -17 38 -14 98 8 129 18 25 505 517 513 517 3 0 26 -19 51 -43z m231 -127
c19 -6 62 -13 95 -17 33 -3 62 -7 65 -10 2 -2 -96 -104 -218 -226 -123 -122
-232 -236 -243 -254 -11 -18 -23 -57 -26 -88 -7 -63 -24 -79 -80 -77 -95 4
-160 97 -130 187 12 36 463 495 487 495 8 0 31 -5 50 -10z"/>
</g>
</svg>
</file>

<file path="public/icons/site.webmanifest">
{
  "name": "",
  "short_name": "",
  "icons": [
    {
      "src": "/icons/android-chrome-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/android-chrome-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    }
  ],
  "theme_color": "#202020",
  "background_color": "#202020",
  "display": "standalone"
}
</file>

<file path="src/components/Player/ChapterMarker.tsx">
export function ChapterMarker(props: {leftAmt: string}) {
  return (
    <span
      data-role="chapterMarker"
      class="w-1 h-full inline-block bg-primary absolute"
      style={{left: `${props.leftAmt}%`}}
    />
  );
}

export function cleanUpOldChapters() {
  const elements = document.querySelectorAll('[data-role="chapterMarker"]');
  elements.forEach((element) => {
    element.remove();
  });
}
</file>

<file path="src/components/Player/SeekBarText.tsx">
import type {Accessor} from "solid-js";

interface ISeekBarChapterText {
  text: Accessor<string>;
}
export function SeekBarChapterText(props: ISeekBarChapterText) {
  return (
    // <Show when={props.text}>
    <span data-role="chapLabelTextHolder" class="chapLabelTextHolder">
      {props.text()}
    </span>
    // </Show>
  );
}
</file>

<file path="src/components/Heading.tsx">
import type {JSX} from "solid-js";
import {splitProps} from "solid-js";

function headingClass(level: number) {
  switch (level) {
    case 1:
      return "text-3xl";
    case 2:
      return "text-2xl";
    case 3:
      return "text-xl";
    default:
      return "";
  }
}

interface HeadingProps2 extends JSX.HTMLAttributes<HTMLHeadingElement> {
  classes?: string;
}

const H1 = (props: HeadingProps2) => {
  const [local, rest] = splitProps(props, ["classes"]);
  return (
    <h1 class={` ${headingClass(1)} ${local.classes}`} {...rest}>
      {props.children}
    </h1>
  );
};
const H2 = (props: HeadingProps2) => {
  const [local, rest] = splitProps(props, ["classes"]);

  return (
    <h1 class={` ${headingClass(2)} ${local.classes}`} {...rest}>
      {props.children}
    </h1>
  );
};
const H3 = (props: HeadingProps2) => {
  const [local, rest] = splitProps(props, ["classes"]);

  return (
    <h1 class={` ${headingClass(3)} ${local.classes}`} {...rest}>
      {props.children}
    </h1>
  );
};
const H4 = (props: HeadingProps2) => {
  const [local, rest] = splitProps(props, ["classes"]);

  return (
    <h1 class={` ${headingClass(4)} ${local.classes}`} {...rest}>
      {props.children}
    </h1>
  );
};

export {H1, H2, H3, H4};
</file>

<file path=".github/workflows/playwright.yml">
name: Playwright Tests
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
jobs:
  test:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: lts/*
    - name: Install dependencies
      run: npm install -g pnpm && pnpm install
    - name: Install Playwright Browsers
      run: pnpm exec playwright install --with-deps
    - name: Run Playwright tests
      run: pnpm exec playwright test
    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30
</file>

<file path="public/icons/Dot_logo.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   version="1.1"
   width="300"
   height="300"
   id="svg19"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs19" />
  <path
     style="fill:#706559;stroke-width:0.698147;fill-opacity:1"
     id="path19-5-13-8-5-3-5"
     d="m 172.66983,97.411705 a 8.4730072,8.2320461 0 0 1 -8.47175,8.232045 8.4730072,8.2320461 0 0 1 -8.47426,-8.229596 8.4730072,8.2320461 0 0 1 8.46922,-8.234494 8.4730072,8.2320461 0 0 1 8.47679,8.227147 l -8.47301,0.0049 z" />
  <path
     style="fill:#706559;stroke-width:0.921315;fill-opacity:1"
     id="path19-5-13-8-5"
     d="m 238.72757,98.954636 a 11.18147,10.863484 0 0 1 -11.17981,10.863484 11.18147,10.863484 0 0 1 -11.18313,-10.860252 11.18147,10.863484 0 0 1 11.17648,-10.866716 11.18147,10.863484 0 0 1 11.18645,10.85702 l -11.18146,0.0065 z" />
  <path
     style="fill:#706559;stroke-width:0.698147;fill-opacity:1"
     id="path19-5-13-8-5-3"
     d="m 201.83763,108.33508 a 8.4730072,8.2320461 0 0 1 -8.47175,8.23205 8.4730072,8.2320461 0 0 1 -8.47426,-8.2296 8.4730072,8.2320461 0 0 1 8.46922,-8.23449 8.4730072,8.2320461 0 0 1 8.47679,8.22714 l -8.47301,0.005 z" />
  <path
     style="fill:#706559;stroke-width:0.921315;fill-opacity:1"
     id="path19-5-13-8-8"
     d="M 213.36294,75.863487 A 11.18147,10.863484 0 0 1 202.18314,86.726972 11.18147,10.863484 0 0 1 191,75.866719 11.18147,10.863484 0 0 1 202.17648,65.000004 11.18147,10.863484 0 0 1 213.36294,75.857023 l -11.18147,0.0065 z" />
  <path
     style="fill:#706559;stroke-width:0.921315;fill-opacity:1"
     id="path19-5-13-8"
     d="m 178.00338,63.336445 a 11.18147,10.863484 0 0 1 -11.1798,10.863484 11.18147,10.863484 0 0 1 -11.18313,-10.860252 11.18147,10.863484 0 0 1 11.17647,-10.866715 11.18147,10.863484 0 0 1 11.18646,10.857019 l -11.18147,0.0065 z" />
  <path
     style="fill:#706559;stroke-width:1.03658;fill-opacity:1"
     id="path19-5-13"
     d="M 180.94495,26.538666 A 12.657432,12.148199 0 0 1 168.2894,38.686865 12.657432,12.148199 0 0 1 155.63009,26.54228 a 12.657432,12.148199 0 0 1 12.65178,-12.151812 12.657432,12.148199 0 0 1 12.66308,12.14097 l -12.65743,0.0072 z" />
  <path
     style="fill:#706559;stroke-width:1.03658;fill-opacity:1"
     id="path19-5-1"
     d="M 223.22372,37.500069 A 12.657432,12.148199 0 0 1 210.56817,49.648268 12.657432,12.148199 0 0 1 197.90885,37.503683 12.657432,12.148199 0 0 1 210.56064,25.351871 12.657432,12.148199 0 0 1 223.22371,37.49284 l -12.65743,0.0072 z" />
  <path
     style="fill:#706559;stroke-width:1.03658;fill-opacity:1"
     id="path19-5"
     d="M 255.74653,62.828197 A 12.657432,12.148199 0 0 1 243.09098,74.976396 12.657432,12.148199 0 0 1 230.43167,62.831812 12.657432,12.148199 0 0 1 243.08345,50.68 12.657432,12.148199 0 0 1 255.74653,62.820969 l -12.65743,0.0072 z" />
  <path
     style="fill:#706559;stroke-width:1.03658;fill-opacity:1"
     id="path19"
     d="M 277.81835,92.531715 A 12.657432,12.148199 0 0 1 265.1628,104.67991 12.657432,12.148199 0 0 1 252.50349,92.53533 12.657432,12.148199 0 0 1 265.15527,80.383518 12.657432,12.148199 0 0 1 277.81835,92.524487 l -12.65743,0.0072 z" />
  <path
     d="M0 0 C0 5.94 0 11.88 0 18 C-4.2384375 18.5878125 -4.2384375 18.5878125 -8.5625 19.1875 C-28.53218622 22.24027808 -46.45352241 30.06674799 -62 43 C-62.88429687 43.7321875 -63.76859375 44.464375 -64.6796875 45.21875 C-85.20806913 62.93929827 -96.92461945 88.33703088 -100 115 C-101.58447607 142.33065888 -95.22918837 170.54621156 -77.0234375 191.73828125 C-76.35570312 192.48464844 -75.68796875 193.23101562 -75 194 C-73.93652344 195.25876953 -73.93652344 195.25876953 -72.8515625 196.54296875 C-55.43729021 216.73741433 -28.92398667 229.87483911 -2.26171875 231.90625 C-1.51535156 231.9371875 -0.76898438 231.968125 0 232 C0.98355469 232.0515625 1.96710938 232.103125 2.98046875 232.15625 C32.71558764 232.97747308 60.33195764 221.75709977 81.94970703 201.49951172 C100.36920833 183.63833981 112.46614615 158.19670071 113.3359375 132.43359375 C113.36535667 130.10171172 113.37788562 127.76956582 113.375 125.4375 C113.37483887 124.21329346 113.37467773 122.98908691 113.37451172 121.7277832 C113.2490892 111.69068098 111.82520837 102.59952186 109 93 C108.01 89.535 108.01 89.535 107 86 C113.27 86 119.54 86 126 86 C134.68593114 109.16248303 134.50170983 135.2489666 128 159 C127.82871582 159.65677734 127.65743164 160.31355469 127.48095703 160.99023438 C118.92242249 192.98813681 95.65921404 219.09082597 67.52734375 235.51953125 C49.1090559 245.86982095 28.53989985 250.4361172 7.5625 250.375 C6.85923584 250.37445618 6.15597168 250.37391235 5.43139648 250.37335205 C-28.08239297 250.25454253 -56.69649291 237.99603994 -81 215 C-81.8353125 214.22914063 -82.670625 213.45828125 -83.53125 212.6640625 C-107.30766427 189.98840815 -118.58926176 157.31348515 -119.375 125 C-118.60248974 94.43949393 -108.58363348 64.91799708 -88 42 C-87.47422363 41.41379883 -86.94844727 40.82759766 -86.40673828 40.22363281 C-64.66905633 16.42456359 -32.60828699 0 0 0 Z "
     fill="#706559"
     transform="translate(142,35)"
     id="path1" />
  <path
     d="M0 0 C7.94978387 6.47616539 11.73826896 14.84767165 13.125 24.8125 C13.94123594 37.7780939 12.74521166 49.61393972 4.125 59.8125 C-1.27718987 65.59512578 -7.49598028 68.79344411 -15.4609375 69.24609375 C-17.05712575 69.26914578 -18.65376995 69.26994885 -20.25 69.25 C-21.50127686 69.24081543 -21.50127686 69.24081543 -22.77783203 69.23144531 C-31.24754602 69.01668759 -38.80247274 67.05370857 -44.875 60.8125 C-54.27356403 49.07634441 -55.22171998 36.38382352 -53.875 21.8125 C-52.0159404 12.51720201 -47.23518618 4.98482537 -39.5625 -0.5625 C-28.22589158 -7.53887441 -11.21617882 -7.32889388 0 0 Z M-33.875 13.8125 C-39.38025246 22.34057512 -39.97404748 31.48185329 -38.484375 41.41796875 C-36.82258997 47.60705275 -33.11332494 51.2639573 -27.875 54.8125 C-22.7078841 56.53487197 -17.76900242 56.46811622 -12.625 54.6875 C-7.29321191 51.05218994 -4.50769118 46.98770085 -2.875 40.8125 C-2.00746058 32.55431148 -1.60620534 23.11076183 -5.875 15.8125 C-10.44638304 11.02947885 -13.87924918 8.65552324 -20.5625 8.4375 C-26.3722966 8.5070784 -30.03036653 9.33425376 -33.875 13.8125 Z "
     fill="#83A640"
     transform="translate(169.875,130.1875)"
     id="path2" />
  <path
     d="M0 0 C42.7037037 0 42.7037037 0 51 8 C58.37754165 15.68493922 59.4593318 25.83514852 59.35351562 36.08007812 C59.02331862 45.97655422 56.36958926 56.05031661 49.58984375 63.5625 C43.27315669 69.22225161 37.12884604 70.45188872 29.00390625 70.29296875 C28.26394409 70.28994751 27.52398193 70.28692627 26.76159668 70.28381348 C24.02842017 70.26825619 21.29544433 70.22637333 18.5625 70.1875 C12.436875 70.125625 6.31125 70.06375 0 70 C0 46.9 0 23.8 0 0 Z M15 13 C15 27.52 15 42.04 15 57 C31.23513556 58.4725312 31.23513556 58.4725312 37.4375 54.5 C42.71972733 49.08233095 43.50486251 41.17716975 43.4375 34 C43.45748047 33.24460937 43.47746094 32.48921875 43.49804688 31.7109375 C43.49320658 26.07683792 42.18693526 21.68559139 39 17 C31.66926153 11.31867768 24.49677822 13 15 13 Z "
     fill="#B65659"
     transform="translate(54,127)"
     id="path3" />
  <path
     d="M0 0 C18.81 0 37.62 0 57 0 C57 4.62 57 9.24 57 14 C50.07 14 43.14 14 36 14 C36 32.48 36 50.96 36 70 C31.05 70 26.1 70 21 70 C21 51.52 21 33.04 21 14 C14.07 14 7.14 14 0 14 C0 9.38 0 4.76 0 0 Z "
     fill="#E6A23E"
     transform="translate(183,127)"
     id="path4" />
</svg>
</file>

<file path="src/components/DownloadForm/DownloadSwitch.tsx">
import {Switch} from "@kobalte/core";

interface IDownloadSwitch {
  formName: string;
  defaultIsChecked: boolean;
  onCheckedChange: (arg: boolean) => void;
  switchLabel: string;
}
export function DownloadSwitch(props: IDownloadSwitch) {
  return (
    <Switch.Root
      defaultChecked={props.defaultIsChecked}
      name={props.formName}
      class="switch"
      onChange={(val: boolean) => props.onCheckedChange(val)}
    >
      <Switch.Label class="switch__label">{props.switchLabel}</Switch.Label>
      <Switch.Input class="switch__input" />
      <Switch.Control class="w-12 h-6 rounded-full bg-surface/20 grid place-content-center relative p-2 relative data-[checked]:(bg-primary/30)">
        <Switch.Thumb class="rounded-full h-full w-1/2 absolute left-0 bg-surface/10 transition duration-150 data-[checked]:text-primary/80 data-[checked]:(translate-x-100% bg-primary)" />
      </Switch.Control>
    </Switch.Root>
  );
}
</file>

<file path="src/i18n/index.ts">
// I would love to automoate this, but for now manual
export const supportedLanguages = [
  {
    code: "en",
    name: "English",
  },
  {
    code: "fr",
    name: "French",
  },
] as const;
// type supportedLocales = "en" | "fr";
export const baseLocale = "en";
</file>

<file path="src/licenses/another.md">
# Licence

Another!
Traduction en langue des signes du Bénin ©2023 La Bible en Toutes Langues Communauté de Missions.
Publié sous une licence internationale Creative Commons Attribution-Share Alike 4.0.

La traduction est basée sur la Bible Louis Segond 1910 du domaine public, disponible sur  [https://bibleineverylanguage.org](https://bibleineverylanguage.org)
Pour en savoir plus sur la licence Creative Commons, visitez le site https://creativecommons.org/licenses/by-sa/4.0/deed.fr.
[https://creativecommons.org/licenses/by-sa/4.0/deed.fr](https://creativecommons.org/licenses/by-sa/4.0/deed.fr)
</file>

<file path="src/licenses/brazil.md">
# ©2025 Comunidade Missionária Bíblia em Todas as Línguas
Distribuído sob a Licença Internacional Creative Commons Atribuição-CompartilhaIgual 4.0.

Esta tradução é baseada na Bíblia Desbloqueada Literal em Português do Brasil, da Wycliffe Associates, sob a licença CC BY-SA 4.0. A Bíblia Desbloqueada Literal em Português do Brasil está disponível em https://bibleineverylanguage.org/resources/languages.

Para mais informações sobre a Licença Creative Commons, visite https://creativecommons.org/licenses/by-sa/4.0/.
</file>

<file path="src/licenses/cotdivoir.md">
# Langue des signes de Côte d'Ivoire Nouveau Testament
©2023 La Bible en Toutes Langues Communauté de Missions.
Publié sous une licence internationale Creative Commons Attribution-Share Alike 4.0.

La traduction est basée sur la Bible Louis Segond 1910 du domaine public, disponible sur  [https://bibleineverylanguage.org](https://bibleineverylanguage.org). 
Pour en savoir plus sur la licence Creative Commons, visitez le site [https://creativecommons.org/licenses/by-sa/4.0/deed.fr](https://creativecommons.org/licenses/by-sa/4.0/deed.fr)
</file>

<file path="src/licenses/ghana.md">
# Ghanaian Sign Language New Testament
©2023 Bible in Every Language Missions Community
Released under a Creative Commons Attribution-Share Alike 4.0 International License.

This translation is based on the English Unlocked Literal Bible by Wycliffe Associates, CC BY-SA 4.0, available at [https://bibleineverylanguage.org/translations](https://bibleineverylanguage.org/translations).
For more information about the Creative Commons License visit [https://creativecommons.org/licenses/by-sa/4.0/](https://creativecommons.org/licenses/by-sa/4.0/).
</file>

<file path="src/licenses/malawi.md">
# Malawian Sign Language New Testament
©2023 Bible in Every Language Missions Community
Released under a Creative Commons Attribution-Share Alike 4.0 International License.

This translation is based on the English Unlocked Literal Bible by Wycliffe Associates, CC BY-SA 4.0, available at [https://bibleineverylanguage.org/translations](https://bibleineverylanguage.org/translations).
For more information about the Creative Commons License visit [https://creativecommons.org/licenses/by-sa/4.0/](https://creativecommons.org/licenses/by-sa/4.0/).
</file>

<file path="src/licenses/malayalam.md">
# ©2025 ബൈബിൾ ഇൻ എവരി ലാംഗ്വേജ് മിഷൻസ് കമ്മ്യൂണിറ്റി
Creative Commons Attribution-Share Alike 4.0 International License പ്രകാരം പുറത്തിറക്കിയത്.

CC BY-SA 4.0 പ്രകാരം വൈക്ലിഫ് അസോസിയേറ്റ്‌സിന്റെ മലയാളം അൺലോക്ക്ഡ് ലിറ്ററൽ ബൈബിളിനെ അടിസ്ഥാനമാക്കിയുള്ളതാണ് ഈ വിവർത്തനം. മലയാളം അൺലോക്ക്ഡ് ലിറ്ററൽ ബൈബിൾ https://bibleineverylanguage.org/resources/languages ൽ ലഭ്യമാണ്.

ക്രിയേറ്റീവ് കോമൺസ് ലൈസൻസിനെക്കുറിച്ചുള്ള കൂടുതൽ വിവരങ്ങൾക്ക്, https://creativecommons.org/licenses/by-sa/4.0/ സന്ദർശിക്കുക.
</file>

<file path="src/licenses/marathi.md">
The word for License in Marathi is परवाना 

# मराठी सांकेतिक भाषा बायबल 

© 2018 प्रत्येक भाषा मिशन समुदायात बायबल 

हे भाषांतर Creative Commons Attribution-ShareAlike 4.0 इंटरनॅशनल लायसन्स अंतर्गत प्रसिद्ध झाले आहे. 

हे [https://bibleineverylanguage.org](https://bibleineverylanguage.org) वर उपलब्ध असलेल्या मराठी अनलॉक केलेल्या लिटरल बायबलवर आधारित आहे. 

क्रिएटिव्ह कॉमन्स परवान्याबद्दल अधिक माहितीसाठी [https://creativecommons.org/licenses/by-sa/4.0](https://creativecommons.org/licenses/by-sa/4.0) ला भेट द्या.
</file>

<file path="src/licenses/paraguay.md">
# ©2025 Comunidad de Misiones de la Biblia en Todos los Idiomas
Publicada bajo la Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional.

Esta traducción se basa en la versión en español latinoamericano ULB de Wycliffe Associates bajo CC BY-SA 4.0. La versión en español latinoamericano ULB está disponible en https://bibleineverylanguage.org/resources/languages.

Para más información sobre la Licencia Creative Commons, visite https://creativecommons.org/licenses/by-sa/4.0/.
</file>

<file path="src/licenses/tanzania.md">
# Lugha ya Ishara ya Tanzania Agano Jipya
©2023 Biblia katika Kila Jumuiya ya Misheni ya Lugha.
Imetolewa chini ya Creative Commons Attribution-Shiriki Sawa 4.0 Leseni ya Kimataifa.

Tafsiri hii inatokana na Biblia ya Kiingereza Unlocked Literal Bible ya Wycliffe Associates, CC BY-SA 4.0, inayopatikana katika [https://bibleineverylanguage.org](https://bibleineverylanguage.org/translations). Kwa maelezo zaidi kuhusu Leseni ya Creative Commons tembelea [https://creativecommons.org/licenses/by-sa/4.0/](https://creativecommons.org/licenses/by-sa/4.0/).
</file>

<file path="src/licenses/togo.md">
# Langue des signes du Togo Nouveau Testament 
©2023 La Bible en Toutes Langues Communauté de Missions.
Publié sous une licence internationale Creative Commons Attribution-Share Alike 4.0.

La traduction est basée sur la Bible Louis Segond 1910 du domaine public, disponible sur [https://bibleineverylanguage.org](https://bibleineverylanguage.org)
Pour en savoir plus sur la licence Creative Commons, visitez le site [https://creativecommons.org/licenses/by-sa/4.0/deed.fr](https://creativecommons.org/licenses/by-sa/4.0/deed.fr)
</file>

<file path="src/pages/api/getId.ts">
import type {APIRoute} from "astro";

export const GET: APIRoute = async (context) => {
  const runtime = context.locals.runtime;
  const env = runtime.env;
  const accountId = String(env.ACCOUNT_ID);
  const playerId = String(env.PLAYER_ID);

  if (!accountId || !playerId) {
    return new Response(null, {
      status: 400,
      statusText: "Missing vars",
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  }

  try {
    const data = JSON.stringify({accountId, playerId});
    return new Response(data, {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (error) {
    console.error(error);
    return new Response(null, {
      status: 404,
    });
  }
};
</file>

<file path="src/pages/404.astro">
---
import Layout from "@layouts/Layout.astro";
---

<Layout title="404" initialDict={{}} preferredLocale="en">
  <div class="h-screen grid w-full place-content-center text-3xl">404</div>
</Layout>
</file>

<file path="src/constants.ts">
export const BibleBookCategories = {
  OT: [
    "GEN",
    "EXO",
    "LEV",
    "NUM",
    "DEU",
    "JOS",
    "JDG",
    "RUT",
    "1SA",
    "2SA",
    "1KI",
    "2KI",
    "1CH",
    "2CH",
    "EZR",
    "NEH",
    "EST",
    "JOB",
    "PSA",
    "PRO",
    "ECC",
    "SNG",
    "ISA",
    "JER",
    "LAM",
    "EZK",
    "DAN",
    "HOS",
    "JOL",
    "AMO",
    "OBA",
    "JON",
    "MIC",
    "NAM",
    "HAB",
    "ZEP",
    "HAG",
    "ZEC",
    "MAL",
  ],
  NT: [
    "MAT",
    "MRK",
    "LUK",
    "JHN",
    "ACT",
    "ROM",
    "1CO",
    "2CO",
    "GAL",
    "EPH",
    "PHP",
    "COL",
    "1TH",
    "2TH",
    "1TI",
    "2TI",
    "TIT",
    "PHM",
    "HEB",
    "JAS",
    "1PE",
    "2PE",
    "1JN",
    "2JN",
    "3JN",
    "JUD",
    "REV",
  ],
};
interface sortOrderI {
  [key: string]: number;
}
const bibleBookSortOrder = Object.values(BibleBookCategories)
  .flat()
  .reduce((acc: sortOrderI, value: string, index: number) => {
    acc[value] = index + 1;
    return acc;
  }, {});
export {bibleBookSortOrder};

export function getBibleBookSort(bookSlug: string) {
  const normalized = bookSlug.normalize().toUpperCase();
  const sortOrder = bibleBookSortOrder[normalized];
  return sortOrder;
}

export const PLAYER_LOADER_OPTIONS = {
  // refNode: playerRef,
  refNodeInsert: "replace",
  controls: true,
  embedType: "in-page",
  options: {
    responsive: true,
    fluid: true,
    fill: true,
    controls: true,
    playbackRates: [0.5, 1, 1.5, 2, 2.5],
    preload: "auto",
    fullscreen: {
      navigationUI: "show",
    },
  },
  // id: 6312743832112,
  // videoId: currentVid().id,
};
export const SW_CACHE_NAME = "dot-downloads";
</file>

<file path="src/env.d.ts">
/// <reference types="astro/client" />
/// <reference types="vite-plugin-pwa/client" />
/// <reference types="video.js" />

type Runtime = import("@astrojs/cloudflare").Runtime<Env>;

declare namespace App {
  interface Locals extends Runtime {}
}
declare module "@brightcove/player-loader";
</file>

<file path="src/pwa.ts">
import {registerSW} from "virtual:pwa-register";

const updateSW = registerSW({
  immediate: true,
  onRegisteredSW(swScriptUrl) {
    console.log("SW registered: ", swScriptUrl);
  },
  onOfflineReady() {
    console.log("PWA application ready to work offline");
  },
  onNeedRefresh() {
    console.log("SW needs refresh, updating...");
    updateSW(true);
  },
});
</file>

<file path="tests/e2e/download-simple.spec.ts">
import { test, expect } from '@playwright/test';
import { waitForVideoPlayer } from '../fixtures/test-helpers';

test.describe('Simple Download Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForVideoPlayer(page);
  });

  test('download form exists with correct structure', async ({ page }) => {
    // Find the download form area
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    await expect(downloadArea).toBeVisible();

    // Verify the form exists
    const form = downloadArea.locator('form');
    await expect(form).toHaveAttribute('name', 'downloadData');
    await expect(form).toHaveAttribute('method', 'post');
  });

  test('download form has required hidden inputs', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    
    // Check swPayload input exists
    const swPayloadInput = downloadArea.locator('input[name="swPayload"]');
    await expect(swPayloadInput).toBeAttached();
    await expect(swPayloadInput).toHaveAttribute('type', 'hidden');
    
    // Verify swPayload has a value (JSON array)
    const swPayloadValue = await swPayloadInput.inputValue();
    expect(swPayloadValue).toBeTruthy();
    expect(() => JSON.parse(swPayloadValue)).not.toThrow();
    
    // Check swDownloadDevice input exists
    const swDownloadDeviceInput = downloadArea.locator('input[name="swDownloadDevice"]');
    await expect(swDownloadDeviceInput).toBeAttached();
    await expect(swDownloadDeviceInput).toHaveAttribute('type', 'hidden');
    
    // Verify swDownloadDevice value is "true"
    const swDownloadDeviceValue = await swDownloadDeviceInput.inputValue();
    expect(swDownloadDeviceValue).toBe('true');
  });

  test('download button triggers form submission', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    const form = downloadArea.locator('form');
    
    // Listen for form submission event
    const formSubmittedPromise = page.evaluate(() => {
      return new Promise<boolean>((resolve) => {
        const form = document.querySelector('form[name="downloadData"]');
        if (form) {
          form.addEventListener('submit', () => resolve(true));
        }
      });
    });
    
    // Click the download button (button inside form)
    const downloadButton = form.locator('button[type="submit"]');
    await expect(downloadButton).toBeVisible();
    
    // Click the button - this should trigger form submission
    await downloadButton.click();
    
    // Verify form was submitted
    const wasSubmitted = await formSubmittedPromise;
    expect(wasSubmitted).toBe(true);
  });

  test('download button is accessible', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    const form = downloadArea.locator('form');
    const downloadButton = form.locator('button[type="submit"]');
    
    // Check button is visible
    await expect(downloadButton).toBeVisible();
    
    // Check button can receive focus
    await downloadButton.focus();
    await expect(downloadButton).toBeFocused();
    
    // Check Enter key triggers form submission
    let keyPressed = false;
    page.on('console', msg => {
      if (msg.type() === 'log') {
        keyPressed = true;
      }
    });
    
    await downloadButton.press('Enter');
    // The form should submit on Enter press
    // This is a basic accessibility check - in a real test we'd verify submission more thoroughly
  });

  test('swDownloadDevice input maintains correct value', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    const swDownloadDeviceInput = downloadArea.locator('input[name="swDownloadDevice"]');
    
    // Verify initial value is "true"
    await expect(swDownloadDeviceInput).toHaveValue('true');
    
    // Navigate to a different video
    await page.getByTestId('book-button-mrk').click();
    await page.waitForTimeout(500);
    
    // Verify swDownloadDevice still has value "true" after navigation
    await expect(swDownloadDeviceInput).toHaveValue('true');
  });

  test('swPayload input contains valid video data', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    const swPayloadInput = downloadArea.locator('input[name="swPayload"]');
    
    const swPayloadValue = await swPayloadInput.inputValue();
    const payload = JSON.parse(swPayloadValue);
    
    // Verify payload is an array
    expect(Array.isArray(payload)).toBe(true);
    
    // Verify array has at least one item
    expect(payload.length).toBeGreaterThan(0);
    
    // Verify payload item has expected structure (video URL and quality)
    const videoPayload = payload[0];
    expect(videoPayload).toHaveProperty('src');
    expect(videoPayload).toHaveProperty('name');
    expect(typeof videoPayload.src).toBe('string');
    expect(typeof videoPayload.name).toBe('string');
  });

  test('form action URL is configured', async ({ page }) => {
    const downloadArea = page.locator('[data-title="downloadCurrentVid"]');
    const form = downloadArea.locator('form');
    
    // Get action attribute value
    const actionUrl = await form.getAttribute('action');
    
    // Verify action URL is set
    expect(actionUrl).not.toBeNull();
    if (actionUrl) {
      expect(typeof actionUrl).toBe('string');
      expect(actionUrl.length).toBeGreaterThan(0);
    }
  });
});
</file>

<file path="tests/e2e/download.spec.ts">
import { test, expect } from '@playwright/test';
import { waitForVideoPlayer } from '../fixtures/test-helpers';

test.describe.skip('Download Functionality Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForVideoPlayer(page);
  });

  test('download form is accessible', async ({ page }) => {
    const downloadForm = page.locator('[data-testid="download-form"]');
    
    // Wait for form to be available (it might be in a menu or modal)
    await downloadForm.waitFor({ state: 'visible', timeout: 5000 });
    
    // Verify form elements are present
    await expect(page.locator('[data-testid="download-scope-radio-group"]')).toBeVisible();
  });

  test('download scope radio buttons work', async ({ page }) => {
    // Wait for download form to be visible
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    const radioGroup = page.locator('[data-testid="download-scope-radio-group"]');
    
    // Check initial state
    const chapterOption = page.locator('[data-testid="download-scope-chapter"]');
    const bookOption = page.locator('[data-testid="download-scope-book"]');
    
    await expect(chapterOption).toBeChecked();
    await expect(bookOption).not.toBeChecked();
    
    // Switch to "Whole Book" option
    await bookOption.click();
    await expect(bookOption).toBeChecked();
    await expect(chapterOption).not.toBeChecked();
    
    // Switch back to "Just this video"
    await chapterOption.click();
    await expect(chapterOption).toBeChecked();
    await expect(bookOption).not.toBeChecked();
  });

  test('quality dropdown updates based on scope selection', async ({ page }) => {
    // Wait for download form
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Initially should show single video quality select
    await expect(page.locator('[data-testid="download-quality-single-video"]')).toBeVisible();
    await expect(page.locator('[data-testid="download-quality-whole-book"]')).not.toBeVisible();
    
    // Switch to whole book
    await page.locator('[data-testid="download-scope-book"]').click();
    
    // Should now show whole book quality select
    await expect(page.locator('[data-testid="download-quality-whole-book"]')).toBeVisible();
    await expect(page.locator('[data-testid="download-quality-single-video"]')).not.toBeVisible();
    
    // Switch back to single video
    await page.locator('[data-testid="download-scope-chapter"]').click();
    
    // Should show single video quality select again
    await expect(page.locator('[data-testid="download-quality-single-video"]')).toBeVisible();
    await expect(page.locator('[data-testid="download-quality-whole-book"]')).not.toBeVisible();
  });

  test('quality dropdowns have options', async ({ page }) => {
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Test single video quality dropdown
    const singleVideoSelect = page.locator('[data-testid="download-quality-single-video"]');
    await expect(singleVideoSelect).toBeVisible();
    
    // Open dropdown to check options
    await singleVideoSelect.click();
    await page.waitForTimeout(500);
    
    // Should have quality options (at least one option)
    const options = page.locator('[role="option"]');
    await expect(options.first()).toBeVisible();
    
    // Close dropdown
    await page.keyboard.press('Escape');
    
    // Test whole book quality dropdown
    await page.locator('[data-testid="download-scope-book"]').click();
    
    const wholeBookSelect = page.locator('[data-testid="download-quality-whole-book"]');
    await expect(wholeBookSelect).toBeVisible();
    
    // Open dropdown
    await wholeBookSelect.click();
    await page.waitForTimeout(500);
    
    // Should have book quality options
    const bookOptions = page.locator('[role="option"]');
    await expect(bookOptions.first()).toBeVisible();
  });

  test('download toggle switches work', async ({ page }) => {
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Find toggle switches (they have specific labels)
    const downloadToDeviceToggle = page.getByLabel(' Download To Device');
    const saveOfflineToggle = page.getByLabel('Save offline');
    
    // Check initial state (both might be unchecked by default)
    await expect(downloadToDeviceToggle).toBeVisible();
    await expect(saveOfflineToggle).toBeVisible();
    
    // Test toggling "Download To Device"
    if (await downloadToDeviceToggle.isChecked() === false) {
      await downloadToDeviceToggle.click();
      await expect(downloadToDeviceToggle).toBeChecked();
    } else {
      await downloadToDeviceToggle.click();
      await expect(downloadToDeviceToggle).not.toBeChecked();
    }
    
    // Test toggling "Save offline"
    if (await saveOfflineToggle.isChecked() === false) {
      await saveOfflineToggle.click();
      await expect(saveOfflineToggle).toBeChecked();
    } else {
      await saveOfflineToggle.click();
      await expect(saveOfflineToggle).not.toBeChecked();
    }
  });

  test('download form preserves state across navigation', async ({ page }) => {
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Set some download preferences
    await page.locator('[data-testid="download-scope-book"]').click();
    
    const downloadToDeviceToggle = page.getByLabel(' Download To Device');
    if (await downloadToDeviceToggle.isChecked() === false) {
      await downloadToDeviceToggle.click();
    }
    
    // Navigate to different chapter
    await page.locator('[data-testid="chapter-button-005"]').click();
    await page.waitForTimeout(2000);
    
    // Check if download form still exists and preferences are preserved
    await expect(page.locator('[data-testid="download-scope-book"]')).toBeChecked();
    await expect(downloadToDeviceToggle).toBeChecked();
  });

  test('download form accessibility', async ({ page }) => {
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Check that radio buttons are keyboard accessible
    await page.keyboard.press('Tab');
    await expect(page.locator('[data-testid="download-scope-chapter"]')).toBeFocused();
    
    // Test arrow navigation in radio group
    await page.keyboard.press('ArrowDown');
    await expect(page.locator('[data-testid="download-scope-book"]')).toBeFocused();
    
    // Test Space to select
    await page.keyboard.press('Space');
    await expect(page.locator('[data-testid="download-scope-book"]')).toBeChecked();
    
    // Check that dropdowns are keyboard accessible
    await page.keyboard.press('Tab');
    await page.keyboard.press('Tab'); // Navigate to dropdown
    await expect(page.locator('[data-testid="download-quality-whole-book"]')).toBeFocused();
    
    // Test Enter to open
    await page.keyboard.press('Enter');
    await page.waitForTimeout(500);
    
    // Check that options appear
    const options = page.locator('[role="option"]');
    await expect(options.first()).toBeVisible();
  });

  test('download form handles missing video data gracefully', async ({ page }) => {
    // This test ensures the form doesn't break when video data is missing or invalid
    await page.goto('/');
    await waitForVideoPlayer(page);
    
    // Wait for download form
    await page.locator('[data-testid="download-form"]').waitFor({ state: 'visible', timeout: 5000 });
    
    // Try to interact with form elements
    await expect(page.locator('[data-testid="download-scope-radio-group"]')).toBeVisible();
    await expect(page.locator('[data-testid="download-quality-single-video"]')).toBeVisible();
    
    // The form should not throw errors even if video data is incomplete
    await page.locator('[data-testid="download-scope-chapter"]').click();
    await page.locator('[data-testid="download-quality-single-video"]').click();
    
    // Should still be functional
    await expect(page.locator('[data-testid="download-scope-chapter"]')).toBeChecked();
  });
});
</file>

<file path="tests/e2e/page-load.spec.ts">
import { test, expect } from '@playwright/test';
import { waitForVideoPlayer, checkNoConsoleErrors } from '../fixtures/test-helpers';

test.describe('Page Load Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Setup console error checking
    await checkNoConsoleErrors(page);
  });

  test('home page renders successfully', async ({ page }) => {
    await page.goto('/');
    
    // Check page title
    await expect(page).toHaveTitle(/DOT/);
    
    // Wait for video player to load
    await waitForVideoPlayer(page);
    
    // Check that main elements are visible
    await expect(page.getByTestId('header-logo')).toBeVisible();
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
    await expect(page.getByTestId('header-menu-toggle')).toBeVisible();
    await expect(page.getByTestId('video-player-container')).toBeVisible();
    await expect(page.getByTestId('book-navigation-container')).toBeVisible();
    await expect(page.getByTestId('chapter-list-container')).toBeVisible();
  });

  test('video list loads from Brightcove API', async ({ page }) => {
    await page.goto('/');
    
    // Wait for video player and book list to load
    await waitForVideoPlayer(page);
    await page.getByTestId('book-navigation-container').waitFor({ state: 'visible' });
    
    // Check that multiple books are loaded
    const bookButtons = page.getByTestId(/^book-button-/);
    await expect(bookButtons).toHaveCount(27); // 27 books in New Testament
    
    // Check that chapters are loaded for the default book
    const chapterButtons = page.getByTestId(/^chapter-button-/);
    await expect(chapterButtons.first()).toBeVisible();
  });

  test('no console errors on page load', async ({ page }) => {
    await page.goto('/');
    
    // Check for any console errors during page load
    await checkNoConsoleErrors(page);
  });

  test('page loads with correct metadata', async ({ page }) => {
    await page.goto('/');
    
    // Check page structure
    await expect(page.locator('html')).toHaveAttribute('lang');
    await expect(page.locator('head meta[name="viewport"]')).toHaveAttribute('content', /width=device-width/);
  });

  test('responsive design works correctly', async ({ page }) => {
    await page.goto('/');
    
    // Test desktop view
    await page.setViewportSize({ width: 1200, height: 800 });
    await waitForVideoPlayer(page);
    await expect(page.getByTestId('video-player-container')).toBeVisible();
    
    // Test mobile view  
    await page.setViewportSize({ width: 375, height: 667 }); // iPhone size
    await expect(page.getByTestId('video-player-container')).toBeVisible();
    await expect(page.getByTestId('header-menu-toggle')).toBeVisible();
  });
});
</file>

<file path="tests/e2e/responsive.spec.ts">
import { test, expect } from '@playwright/test';
import { waitForVideoPlayer, navigateToBook } from '../fixtures/test-helpers';

test.describe('Responsive Design Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForVideoPlayer(page);
  });

  test('mobile layout works correctly', async ({ page }) => {
    // Set mobile viewport
    await page.setViewportSize({ width: 375, height: 667 }); // iPhone size
    
    // Test header elements
    await expect(page.getByTestId('header-logo')).toBeVisible();
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
    await expect(page.getByTestId('header-menu-toggle')).toBeVisible();
    
    // Test video player
    const playerContainer = page.getByTestId('video-player-container');
    await expect(playerContainer).toBeVisible();
    
    // Verify mobile aspect ratio
    const playerBox = await playerContainer.boundingBox();
    expect(playerBox?.width).toBeLessThanOrEqual(375);
    expect(playerBox?.height).toBeCloseTo(playerBox!.width * 9/16, 0.1);
    
    // Test book navigation on mobile
    const bookNav = page.getByTestId('book-navigation-container');
    await expect(bookNav).toBeVisible();
    
    // Test chapter navigation on mobile - should be scrollable
    const chapterList = page.getByTestId('chapter-list-container');
    await expect(chapterList).toBeVisible();
    
    // Check that chapter buttons are smaller on mobile
    const chapterButton = page.getByTestId('chapter-button-001');
    await expect(chapterButton).toBeVisible();
    const buttonBox = await chapterButton.boundingBox();
    expect(buttonBox?.width).toBeLessThanOrEqual(48); // w-12 = 48px on mobile
  });

  test('tablet layout works correctly', async ({ page }) => {
    // Set tablet viewport
    await page.setViewportSize({ width: 768, height: 1024 }); // iPad size
    
    // Test header elements
    await expect(page.getByTestId('header-logo')).toBeVisible();
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
    await expect(page.getByTestId('header-menu-toggle')).toBeVisible();
    
    // Test video player
    await expect(page.getByTestId('video-player-container')).toBeVisible();
    
    // Test book navigation on tablet
    await expect(page.getByTestId('book-navigation-container')).toBeVisible();
    
    // Test chapter navigation on tablet
    await expect(page.getByTestId('chapter-list-container')).toBeVisible();
    
    // Chapter buttons should be larger on tablet
    const chapterButton = page.getByTestId('chapter-button-001');
    const buttonBox = await chapterButton.boundingBox();
    expect(buttonBox?.width).toBeGreaterThanOrEqual(48); // w-12 = 48px on tablet
  });

  test('desktop layout works correctly', async ({ page }) => {
    // Set desktop viewport
    await page.setViewportSize({ width: 1200, height: 800 });
    
    // Test header elements
    await expect(page.getByTestId('header-logo')).toBeVisible();
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
    await expect(page.getByTestId('header-menu-toggle')).toBeVisible();
    
    // Test video player - should be larger on desktop
    const playerContainer = page.getByTestId('video-player-container');
    await expect(playerContainer).toBeVisible();
    
    const playerBox = await playerContainer.boundingBox();
    expect(playerBox?.width).toBeGreaterThan(600); // Should be wider on desktop
    
    // Test book navigation on desktop
    await expect(page.getByTestId('book-navigation-container')).toBeVisible();
    
    // Test chapter navigation on desktop
    await expect(page.getByTestId('chapter-list-container')).toBeVisible();
  });

  test('navigation drawer works on mobile', async ({ page }) => {
    // Set mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    
    // Open menu
    await page.getByTestId('header-menu-toggle').click();
    await page.waitForTimeout(300);
    
    // Check that menu close button appears (indicates menu is open)
    await expect(page.getByTestId('header-menu-close')).toBeVisible();
    
    // Check that drawer appears
    const drawer = page.locator('.w-full.max-w-md.fixed.right-0');
    await expect(drawer).toBeVisible();
    
    // Check menu items
    await expect(page.getByRole('link', { name: 'License' })).toBeVisible();
    await expect(page.getByRole('link', { name: 'About' })).toBeVisible();
    
    // Note: Closing the menu is difficult because the close button is outside viewport
    // The overlay and drawer use CSS that makes direct clicking challenging
    // This test verifies the menu opens and displays correctly
  });

  test('chapter scrolling works on mobile', async ({ page }) => {
    // Set mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    
    // Navigate to a book with many chapters (like Matthew)
    await navigateToBook(page, 'MAT');
    await page.waitForTimeout(1000);
    
    const chapterList = page.getByTestId('chapter-list-container');
    
    // Check if chapter list is scrollable
    const listBox = await chapterList.boundingBox();
    if (listBox) {
      // Try to scroll the chapter list
      await chapterList.evaluate((el) => {
        el.scrollLeft = 200;
      });
      
      await page.waitForTimeout(500);
      
      // Should be able to scroll (scrollLeft should be > 0)
      const scrollLeft = await chapterList.evaluate((el) => el.scrollLeft);
      expect(scrollLeft).toBeGreaterThan(0);
    }
  });

  test('responsive behavior during viewport changes', async ({ page }) => {
    // Start with mobile
    await page.setViewportSize({ width: 375, height: 667 });
    await waitForVideoPlayer(page);
    
    const playerContainer = page.getByTestId('video-player-container');
    const mobileBox = await playerContainer.boundingBox();
    
    // Switch to desktop
    await page.setViewportSize({ width: 1200, height: 800 });
    await page.waitForTimeout(500); // Wait for layout adjustment
    
    const desktopBox = await playerContainer.boundingBox();
    
    // Player should be wider on desktop
    expect(desktopBox!.width).toBeGreaterThan(mobileBox!.width);
    
    // Switch back to mobile
    await page.setViewportSize({ width: 375, height: 667 });
    await page.waitForTimeout(500);
    
    // Should adapt back to mobile size
    const mobileBox2 = await playerContainer.boundingBox();
    expect(mobileBox2!.width).toBeLessThanOrEqual(375);
  });

  test.skip('touch interactions work on mobile', async ({ page }) => {
    // Set mobile viewport and enable touch
    await page.setViewportSize({ width: 375, height: 667 });
    await page.addInitScript(() => {
      // Simulate touch device
      Object.defineProperty(navigator, 'maxTouchPoints', {
        get: () => 1,
      });
    });
    
    await waitForVideoPlayer(page);
    
    // Test touch interaction with chapter buttons
    const chapterButton = page.getByTestId('chapter-button-002');
    await chapterButton.tap();
    await page.waitForTimeout(1000);
    
    // Should navigate to chapter 2
    // Note: Component doesn't use scale-120 class, checking for successful navigation instead
    await expect(page).toHaveURL(/\/MRK\.002$/);
  });

  test('orientation changes work correctly', async ({ page }) => {
    // Set mobile portrait
    await page.setViewportSize({ width: 375, height: 667 });
    await waitForVideoPlayer(page);
    
    const playerContainer = page.getByTestId('video-player-container');
    const portraitBox = await playerContainer.boundingBox();
    
    // Switch to landscape
    await page.setViewportSize({ width: 667, height: 375 });
    await page.waitForTimeout(500);
    
    const landscapeBox = await playerContainer.boundingBox();
    
    // Should adapt to landscape orientation - width should increase
    expect(landscapeBox!.width).toBeGreaterThan(portraitBox!.width);
    // Height should adjust to maintain aspect ratio
    expect(landscapeBox!.height).toBeGreaterThan(0);
    expect(landscapeBox!.width / landscapeBox!.height).toBeCloseTo(16/9, 1);
  });
});
</file>

<file path="tests/e2e/theme-toggle.spec.ts">
import { test, expect } from '@playwright/test';
import { toggleTheme, verifyTheme, waitForVideoPlayer } from '../fixtures/test-helpers';

test.describe.skip('Theme Toggle Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForVideoPlayer(page);
  });

  test('switch from light to dark mode', async ({ page }) => {
    // Check initial state (should detect system preference or default)
    await page.waitForTimeout(100); // Allow theme to initialize
    
    // Toggle to dark mode
    await toggleTheme(page);
    
    // Verify dark mode is applied
    await verifyTheme(page, true);
    
    // Verify theme toggle button shows sun icon in dark mode
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
  });

  test('switch from dark to light mode', async ({ page }) => {
    // First toggle to dark mode
    await toggleTheme(page);
    await verifyTheme(page, true);
    
    // Toggle back to light mode
    await toggleTheme(page);
    
    // Verify light mode is applied
    await verifyTheme(page, false);
    
    // Verify theme toggle button shows moon icon in light mode
    await expect(page.getByTestId('header-theme-toggle')).toBeVisible();
  });

  test('theme preference persists across page reloads', async ({ page }) => {
    // Set to dark mode
    await toggleTheme(page);
    await verifyTheme(page, true);
    
    // Reload page
    await page.reload();
    await waitForVideoPlayer(page);
    
    // Should still be in dark mode
    await verifyTheme(page, true);
    
    // Switch to light mode
    await toggleTheme(page);
    await verifyTheme(page, false);
    
    // Reload again
    await page.reload();
    await waitForVideoPlayer(page);
    
    // Should still be in light mode
    await verifyTheme(page, false);
  });

  test('theme updates correctly for video player and navigation', async ({ page }) => {
    // Check initial appearance
    const playerContainer = page.getByTestId('video-player-container');
    const bookNav = page.getByTestId('book-navigation-container');
    
    // Toggle to dark mode
    await toggleTheme(page);
    await verifyTheme(page, true);
    
    // Verify components are visible in dark mode
    await expect(playerContainer).toBeVisible();
    await expect(bookNav).toBeVisible();
    
    // Toggle back to light mode
    await toggleTheme(page);
    await verifyTheme(page, false);
    
    // Verify components are still visible in light mode
    await expect(playerContainer).toBeVisible();
    await expect(bookNav).toBeVisible();
  });

  test('multiple theme toggles work correctly', async ({ page }) => {
    // Toggle multiple times
    await toggleTheme(page); // dark
    await verifyTheme(page, true);
    
    await toggleTheme(page); // light
    await verifyTheme(page, false);
    
    await toggleTheme(page); // dark
    await verifyTheme(page, true);
    
    await toggleTheme(page); // light
    await verifyTheme(page, false);
  });

  test('theme works correctly after navigation', async ({ page }) => {
    // Set dark theme
    await toggleTheme(page);
    await verifyTheme(page, true);
    
    // Navigate to a different book and chapter
    await page.getByTestId('book-button-mrk').click();
    await page.waitForTimeout(500);
    await page.getByTestId('chapter-button-002').click();
    await page.waitForTimeout(500);
    
    // Theme should still be dark
    await verifyTheme(page, true);
    
    // Toggle to light
    await toggleTheme(page);
    await verifyTheme(page, false);
    
    // Navigate again
    await page.getByTestId('book-button-luk').click();
    await page.waitForTimeout(500);
    
    // Theme should still be light
    await verifyTheme(page, false);
  });

  test('theme toggle button is accessible', async ({ page }) => {
    const themeToggle = page.getByTestId('header-theme-toggle');
    
    // Check that button has proper ARIA attributes
    await expect(themeToggle).toHaveAttribute('aria-label', 'Light Mode or Dark Mode');
    
    // Check that button is keyboard accessible
    await themeToggle.focus();
    await expect(themeToggle).toBeFocused();
    
    // Check that Enter key works
    await themeToggle.press('Enter');
    await page.waitForTimeout(100);
    
    // Theme should have toggled
    const html = page.locator('html');
    const hasDarkClass = await html.getAttribute('class');
    expect(hasDarkClass).toMatch(/dark|light/);
  });
});
</file>

<file path="tests/e2e/video-playback.spec.ts">
import { test, expect } from '@playwright/test';
import { 
  waitForVideoPlayer, 
  waitForVideoLoad,
  navigateToBook, 
  navigateToChapter 
} from '../fixtures/test-helpers';

test.describe('Video Functionality Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await waitForVideoLoad(page);
  });

  test('video player loads and initializes correctly', async ({ page }) => {
    const playerContainer = page.getByTestId('video-player-container');

    // Verify player is visible
    await expect(playerContainer).toBeVisible();

    // Verify video element exists (Video.js creates this)
    const videoElement = page.locator('video');
    await expect(videoElement).toBeVisible();
  });

  test('chapter back button functionality', async ({ page }) => {
    // Navigate to a middle chapter first
    await navigateToBook(page, 'MAT');
    await navigateToChapter(page, '005');
    await waitForVideoLoad(page);

    // Wait a bit for video to load so back button appears
    await page.waitForTimeout(3000);

    const backButton = page.getByTestId('video-player-chapter-back');

    // Check if back button is visible (it might be hidden if no previous chapter)
    const isVisible = await backButton.isVisible();

    if (isVisible) {
      // Click back button
      await backButton.click();
      await page.waitForTimeout(2000);

      // Should navigate to previous chapter
      const currentChapter = page.getByTestId('chapter-button-004');
      await expect(currentChapter).toBeVisible();
    } else {
      // If not visible, verify it's because we're at the first chapter
      const firstChapter = page.getByTestId('chapter-button-001');
      await expect(firstChapter).toBeVisible();
    }
  });

  test('chapter next button functionality', async ({ page }) => {
    // Navigate to a middle chapter
    await navigateToBook(page, 'MAT');
    await navigateToChapter(page, '005');
    await waitForVideoLoad(page);

    // Wait for video to load so next button appears
    await page.waitForTimeout(3000);

    const nextButton = page.getByTestId('video-player-chapter-next');

    // Check if next button is visible
    const isVisible = await nextButton.isVisible();

    if (isVisible) {
      // Click next button
      await nextButton.click();
      await page.waitForTimeout(2000);

      // Should navigate to next chapter
      const nextChapter = page.getByTestId('chapter-button-006');
      await expect(nextChapter).toBeVisible();
    }
  });

  test('speed control slider functionality', async ({ page }) => {
    const speedControl = page.getByTestId('video-player-speed-control');

    // Verify speed control is visible
    await expect(speedControl).toBeVisible();

    // Check initial value (should be 1.0)
    await expect(speedControl).toHaveValue('1');

    // Test changing speed to 1.5
    await speedControl.fill('1.5');
    await expect(speedControl).toHaveValue('1.5');

    // Test changing speed to 0.75
    await speedControl.fill('0.75');
    await expect(speedControl).toHaveValue('0.75');

    // Test max constraint
    await speedControl.fill('5'); // At max
    await expect(speedControl).toHaveValue('5');

    // Test min constraint
    await speedControl.fill('0.25'); // At min
    await expect(speedControl).toHaveValue('0.25');
  });

  test('video controls are accessible', async ({ page }) => {
    const speedControl = page.getByTestId('video-player-speed-control');

    // Test keyboard navigation to speed control
    await speedControl.focus();
    await expect(speedControl).toBeFocused();

    // Test arrow keys for speed control
    await speedControl.press('ArrowRight');
    await page.waitForTimeout(100);
  });

  test('video player responsiveness', async ({ page }) => {
    // Test desktop size
    await page.setViewportSize({ width: 1200, height: 800 });
    await waitForVideoLoad(page);
    
    const playerContainer = page.getByTestId('video-player-container');
    await expect(playerContainer).toBeVisible();
    
    // Test mobile size
    await page.setViewportSize({ width: 375, height: 667 });
    await expect(playerContainer).toBeVisible();
    
    // Verify aspect ratio is maintained
    const boundingBox = await playerContainer.boundingBox();
    expect(boundingBox?.height).toBeCloseTo(boundingBox!.width * 9/16, 0.1);
  });

  test('video player maintains state during navigation', async ({ page }) => {
    // Set speed to 1.5
    const speedControl = page.getByTestId('video-player-speed-control');
    await speedControl.fill('1.5');
    await expect(speedControl).toHaveValue('1.5');
    
    // Navigate to different chapter
    await navigateToChapter(page, '003');
    await waitForVideoLoad(page);
    
    // Speed preference should persist
    await expect(speedControl).toHaveValue('1.5');
  });

  test('chapter buttons update video correctly', async ({ page }) => {
    // Navigate to Matthew
    await navigateToBook(page, 'MAT');
    await waitForVideoLoad(page);

    // Click different chapter buttons
    await page.getByTestId('chapter-button-010').click();
    await page.waitForTimeout(2000);
    await expect(page.getByTestId('chapter-button-010')).toBeVisible();

    await page.getByTestId('chapter-button-015').click();
    await page.waitForTimeout(2000);
    await expect(page.getByTestId('chapter-button-015')).toBeVisible();
  });

  test('video player error handling', async ({ page }) => {
    // Monitor for any error dialogs or messages
    page.on('dialog', async dialog => {
      console.log('Dialog appeared:', dialog.message());
      await dialog.accept();
    });
    
    // Navigate through several videos to check for loading errors
    await navigateToBook(page, 'MAT');
    await navigateToChapter(page, '001');
    await waitForVideoLoad(page);
    
    await navigateToChapter(page, '002');
    await waitForVideoLoad(page);
    
    await navigateToBook(page, 'MRK');
    await waitForVideoLoad(page);
    
    // If we got here without errors, video loading is working
    await expect(page.getByTestId('video-player-container')).toBeVisible();
  });
});
</file>

<file path="tests/fixtures/test-helpers.ts">
import { test, expect, type Page } from '@playwright/test';

// Common test constants
export const TEST_BOOKS = ['MAT', 'MRK', 'LUK', 'JHN'];
export const TEST_CHAPTERS = ['001', '002', '003'];

// Helper functions
export async function waitForVideoPlayer(page: Page) {
  await page.getByTestId('video-player-container').waitFor({ state: 'visible' });
}

export async function navigateToBook(page: Page, book: string) {
  await page.getByTestId(`book-button-${book.toLowerCase()}`).click();
  await waitForVideoPlayer(page);
  // Wait for URL to update
  await page.waitForTimeout(200);
}

export async function navigateToChapter(page: Page, chapter: string) {
  await page.getByTestId(`chapter-button-${chapter}`).click();
  await waitForVideoPlayer(page);
  // Wait for URL to update and component state to reflect
  await page.waitForTimeout(200);
}

export async function toggleTheme(page: Page) {
  await page.getByTestId('header-theme-toggle').click();
  // Wait for theme transition to complete
  await page.waitForTimeout(500);
}

export async function verifyTheme(page: Page, isDark: boolean) {
  const themeToggle = page.getByTestId('header-theme-toggle');
  // Verify theme by checking the aria-pressed attribute of the toggle button
  // When isDark is true, aria-pressed should be "true"
  if (isDark) {
    await expect(themeToggle).toHaveAttribute('aria-pressed', 'true');
  } else {
    await expect(themeToggle).toHaveAttribute('aria-pressed', 'false');
  }
}

export async function openMenu(page: Page) {
  await page.getByTestId('header-menu-toggle').click();
  await page.waitForSelector('[data-testid="header-menu-close"]');
}

export async function closeMenu(page: Page) {
  await page.getByTestId('header-menu-close').click();
  await page.waitForSelector('[data-testid="header-menu-close"]', { state: 'hidden' });
}

export async function waitForVideoLoad(page: Page) {
  // Wait for video player to be ready
  await waitForVideoPlayer(page);
  // Wait a bit for Video.js to initialize
  await page.waitForTimeout(2000);
}

export async function verifyURLPattern(page: Page, expectedPath: string) {
  await expect(page).toHaveURL(new RegExp(`${expectedPath}$`));
}

export async function checkNoConsoleErrors(page: Page) {
  const logs: string[] = [];
  page.on('console', msg => {
    if (msg.type() === 'error') {
      logs.push(msg.text());
    }
  });
  
  // Wait a bit to collect any errors
  await page.waitForTimeout(1000);
  
  if (logs.length > 0) {
    console.error('Console errors found:', logs);
    throw new Error(`Console errors detected: ${logs.join(', ')}`);
  }
}
</file>

<file path="tests/setup.ts">
import {setupServer} from "msw/node";
import {handlers} from "./handlers";

// Setup MSW server for API mocking
const server = setupServer(...handlers);

// Start server before all tests
server.listen({
  onUnhandledRequest: "bypass",
});

// Cleanup after all tests
process.once("SIGINT", () => server.close());
process.once("SIGTERM", () => server.close());

export default () => {
  // Export setup function for Playwright
};
</file>

<file path=".eslintrc.cjs">
module.exports = {
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaVersion: "latest",
    sourceType: "module",
  },
  env: {
    browser: true,
    node: true,
  },
  ignorePatterns: ["functions/*.js", "dist/**/*", "playwright-report/**/*"],
  plugins: ["@typescript-eslint", "solid"],
  extends: [
    "plugin:astro/recommended",
    "plugin:astro/jsx-a11y-recommended",
    "plugin:solid/typescript",
    "plugin:@typescript-eslint/recommended",
  ],
  overrides: [
    {
      files: ["*.astro"],
      parser: "astro-eslint-parser",
      parserOptions: {
        parser: "@typescript-eslint/parser",
        extraFileExtensions: [".astro"],
        sourceType: "module",
      },
      extends: ["plugin:astro/recommended", "plugin:astro/jsx-a11y-strict"],
      rules: {
        "astro/no-conflict-set-directives": "error",
        "astro/no-unused-define-vars-in-style": "error",
        "solid/self-closing-comp": 0,
      },
    },
    {
      files: ["*.jsx", "*.tsx"],
      rules: {
        "solid/no-innerhtml": 0,
      },
    },
    {
      files: ["*.ts"],
      rules: {
        "no-undef": "off",
      },
    },
  ],
};
// https://github.com/ota-meshi/eslint-plugin-astro
</file>

<file path="AGENTS.md">
# DOT Videos - Agent Development Guide

This guide helps agentic coding agents understand and work effectively with the DOT Videos codebase - a Bible video hosting platform powered by Brightcove.

## Project Overview

DOT Videos is a Deaf Owned Translation platform for hosting and organizing Bible videos in a structured format. The platform serves as a digital Bible interface with video content from Brightcove, supporting multiple languages and offline capabilities.

### Technology Stack
- **Framework**: Astro 5.12.8 with server-side rendering
- **UI Framework**: SolidJS for reactive components  
- **Language**: TypeScript (strict mode)
- **Styling**: UnoCSS with custom utility classes
- **PWA**: Service worker with offline capabilities
- **Deployment**: Cloudflare Pages
- **Video**: Brightcove Video.js integration
- **Internationalization**: English/French support

## Development Commands

### Current Commands
```bash
# Development
pnpm dev              # Start development server with --host
pnpm start            # Alias for dev

# Building  
pnpm build            # Production build
pnpm build-tr         # Build with trace warnings for debugging
pnpm preview          # Preview production build locally
pnpm preview-cf       # Cloudflare Pages preview with wrangler
pnpm cf-dev           # Development with Cloudflare proxy

# Quality Assurance
pnpm lint             # Run ESLint on entire codebase
pnpm check            # Run Astro type checking

# Package Management
pnpm install          # Install dependencies
```

### Recommended Testing Commands (To Add)
```bash
# E2E Testing with Playwright (Recommended Setup)
pnpm test:e2e         # Run Playwright e2e tests
pnpm test:e2e:ui      # Run Playwright with UI interface
pnpm test:e2e:debug   # Debug Playwright tests
pnpm test:e2e:install # Install Playwright browsers
```

## Code Style Guidelines

### Import Patterns & Path Aliases
Always use configured path aliases for clean imports:

```typescript
// Components
import { Header } from "@components/Header";
import { VideoPlayer } from "@components/Player";

// Layouts
import Layout from "@layouts/Layout";

// Utilities and libraries
import { formatDuration } from "@utils";
import { getPlaylistData } from "@lib/routes";
import { i18n } from "@i18n/index";

// Types
import type { IVidWithCustom, userPreferencesI } from "@customTypes/types";
```

### Component Patterns

#### SolidJS Components
```typescript
// Use signals for reactive state
const [isPlaying, setIsPlaying] = createSignal(false);
const [currentTime, setCurrentTime] = createSignal(0);

// Use effects for side effects
createEffect(() => {
  if (isPlaying()) {
    // Handle play state
  }
});

// Props interface
interface VideoPlayerProps {
  video: IVidWithCustom;
  onTimeUpdate?: (time: number) => void;
}

export function VideoPlayer(props: VideoPlayerProps) {
  // Component logic
  return (
    <div class="video-container">
      {/* JSX content */}
    </div>
  );
}
```

#### Astro Pages/Components
```astro
---
// Frontmatter for server-side logic
import Layout from "@layouts/Layout.astro";
import { getUserPreferences } from "@utils";

const userPreferences = getUserPreferences(Astro);
const data = await fetchData();
---

<Layout title="DOT Videos">
  <main>
    <slot />
  </main>
</Layout>
```

### Naming Conventions
- **Components**: PascalCase (`VideoPlayer.tsx`, `Header.tsx`, `AppWrapper.tsx`)
- **Functions**: camelCase (`formatDuration`, `getUserPreferences`, `mutateSortVidsArray`)
- **Constants**: UPPER_SNAKE_CASE (`BibleBookCategories`, `PLAYER_LOADER_OPTIONS`)
- **Files**: 
  - Components: PascalCase (`VideoPlayer.tsx`)
  - Utilities: camelCase (`utils.ts`)
  - Pages: kebab-case (`book-chapter.astro`) or index for folders

### TypeScript Guidelines
- Always type function parameters and return values
- Use interfaces for object shapes
- Leverage the existing type definitions in `@customTypes/types`
- Maintain strict mode compliance

```typescript
// Good example
export function formatDuration(milliseconds: number): string {
  const seconds = Math.floor(milliseconds / 1000);
  // Implementation
}

// Use existing types
import type { IVidWithCustom, userPreferencesI } from "@customTypes/types";

const processVideos = (videos: IVidWithCustom[]): IVidWithCustom[] => {
  // Processing logic
};
```

### Styling Guidelines

#### UnoCSS Utilities
Use atomic UnoCSS classes for styling:

```typescript
// Layout
<div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4">

// Typography
<h1 class="text-2xl font-bold text-primary">Title</h1>

// Responsive design
<div class="w-full md:w-1/2 lg:w-1/3">

// Custom utilities from uno.config.ts
<div class="grid-col-fill-200">Custom grid</div>
<div class="scrollbar-hide">Hide scrollbar</div>
```

#### CSS Variables & Theming
Use CSS custom properties defined in `global.css`:

```css
/* Available theme colors */
--clrSurface    /* Background color */
--clrBase       /* Text color */  
--clrPrimary    /* Primary accent color */
--clrSecondary  /* Secondary accent color */
--clrTertiary   /* Tertiary accent color */
```

```typescript
// Apply theme colors
<div class="bg-base text-surface">
  <button class="bg-primary text-base hover:bg-secondary">
    Button
  </button>
</div>
```

#### Dark/Light Theme Support
- Use CSS custom properties for automatic theme switching
- Theme is controlled via `.dark` and `.light` classes on `<html>` element
- User preference is stored in cookies

## Project Structure

```
src/
├── components/          # SolidJS components
│   ├── Player/         # Video player components
│   ├── PlayerNavigation/ # Navigation controls
│   ├── DownloadForm/   # Download functionality
│   └── Icons.tsx       # Icon components
├── pages/              # Astro pages and API routes
│   ├── api/           # API endpoints (Brightcove integration)
│   ├── [bookChap]/    # Dynamic routing for books/chapters
│   ├── index.astro    # Home page
│   └── 404.astro      # Error page
├── layouts/            # Astro layout components
│   └── Layout.astro   # Main site layout
├── lib/               # Utilities and business logic
│   ├── utils.ts       # General utility functions
│   ├── routes.ts      # API route handlers
│   ├── UI.ts          # UI helper functions
│   ├── store.ts       # State management
│   └── pwa.ts         # PWA configuration
├── i18n/              # Internationalization
│   ├── index.ts       # I18n configuration
│   ├── en.ts         # English translations
│   └── fr.ts         # French translations
├── customTypes/        # TypeScript type definitions
├── images/            # Image assets
├── constants.ts       # Application constants
├── domainConfig.ts    # Domain-specific configurations
├── env.d.ts          # Environment variable types
└── global.css        # Global styles and theme variables
```

## Key Architectural Patterns

### Data Flow
1. **Brightcove API** → Astro server-side data fetching → SolidJS client components
2. **I18n** via `@solid-primitives/i18n` with locale detection from headers
3. **State Management** through SolidJS signals and createEffect
4. **PWA** capabilities via custom service worker implementation

### Video Integration
- Video.js player with Brightcove integration
- Custom fields for Bible book/chapter mapping
- Playlist data processing and sorting
- Chapter markers and navigation

### Internationalization
- Currently supports English (`en`) and French (`fr`)
- Locale detection from `Accept-Language` headers
- Dynamic imports for translation files
- Add new locales to `supportedLanguages` array in `src/i18n/index.ts`

### Domain Configuration
Multiple domains are supported via `src/domainConfig.ts`:
- Each domain maps to specific Brightcove playlists
- Configuration includes display names and playlist IDs
- Used for multi-site deployment from single codebase

## Testing Strategy

### Recommended E2E Test Coverage
When implementing Playwright testing, focus on these critical user flows:

1. **Page Load Test**
   - Home page renders successfully
   - Video list loads from Brightcove API
   - No console errors

2. **Navigation Tests**
   - Navigate between books in the Bible
   - Navigate between chapters within books
   - Dynamic routing (`/[bookChap]`) works correctly
   - Browser back/forward navigation

3. **Theme Toggle**
   - Switch between light and dark modes
   - Theme preference persists (cookie-based)
   - UI updates correctly for both themes

4. **Video Functionality**
   - Video playback controls work
   - Chapter markers function properly
   - Video download functionality completes
   - Progress bar and seeking work

5. **Responsive Design**
   - Mobile layout (below md breakpoint)
   - Tablet layout (md breakpoint)
   - Desktop layout (lg breakpoint and above)

### Test Structure Recommendation
```
tests/
├── e2e/
│   ├── setup.ts          # Global test setup
│   ├── page-load.spec.ts # Basic page loading tests
│   ├── navigation.spec.ts # Book/chapter navigation
│   ├── video-playback.spec.ts # Video functionality
│   ├── theme-toggle.spec.ts   # Theme switching
│   ├── download.spec.ts       # Download functionality
│   └── responsive.spec.ts      # Responsive design
├── fixtures/
│   └── test-data.ts     # Mock data and test helpers
└── config/
    └── playwright.config.ts # Playwright configuration
```

## Development Workflow

### Before Making Changes
1. Ensure clean working directory: `git status`
2. Run quality checks: `pnpm lint` and `pnpm check`
3. Create feature branch from `develop` branch
4. Test changes locally with `pnpm dev`

### Before Committing
1. Fix any linting issues: `pnpm lint`
2. Verify TypeScript types: `pnpm check`  
3. Run e2e tests: `pnpm test:e2e`
4. Test production build: `pnpm build`
5. Verify PWA functionality in preview mode

### Common Development Tasks

#### Adding New Components
1. Create component file in appropriate `src/components/` subdirectory
2. Follow SolidJS patterns with proper TypeScript typing
3. Use UnoCSS utilities for styling
4. Export component and add to barrel exports if needed

#### Adding New Pages/Routes
1. Create `.astro` file in `src/pages/`
2. Use existing layout pattern with proper props
3. Handle data fetching in frontmatter
4. Ensure proper TypeScript types for props

#### Internationalization Updates
1. Add translation keys to both `en.ts` and `fr.ts`
2. Use the `t()` function from `@solid-primitives/i18n` in components
3. Test both language variants
4. Update supported languages if adding new locales

#### Styling Updates
1. Prefer UnoCSS utilities over custom CSS
2. Add custom utilities to `uno.config.ts` if needed
3. Use CSS custom properties for theme-aware values
4. Test both light and dark themes

## Important Configuration Details

### ESLint Configuration
- TypeScript strict mode enforcement
- Astro JSX accessibility rules
- SolidJS-specific linting rules
- Custom overrides for different file types
- Automatic fixing of most linting issues

### TypeScript Configuration
- Strict mode enabled with comprehensive type checking
- Path aliases configured for clean imports
- JSX preserve setting for SolidJS compatibility
- Cloudflare worker types included for serverless functions

### UnoCSS Configuration
- Custom theme colors via CSS custom properties
- Custom utility rules for specialized grid layouts
- Montserrat font family configuration
- Responsive breakpoint utilities

### PWA Configuration
- Service worker with custom caching strategies
- Offline video download capabilities
- App manifest for mobile installation
- Background sync for offline functionality

## Special Considerations

### Performance Optimizations
- Bundle size monitoring via rollup-plugin-visualizer
- Lazy loading of video.js localization files
- Efficient image optimization and serving
- Service worker caching for offline access

### Accessibility
- ESLint jsx-a11y rules enforced
- Semantic HTML5 structure
- Keyboard navigation support
- Screen reader compatibility
- ARIA labels where needed

### Security
- Environment variables properly configured
- Cloudflare Workers security headers
- Content Security Policy considerations
- Safe handling of Brightcove API credentials

### Deployment Notes
- Multi-domain support via configuration
- Cloudflare Pages automatic deployments
- PWA features require HTTPS
- Build optimization for various deployment targets

This guide should provide all the essential information for agentic coding agents to work effectively with the DOT Videos codebase while maintaining code quality, consistency, and functionality across the platform.
</file>

<file path="README.md">
# Deaf Owned Translation


An astro site to consume deaf new testaments.
</file>

<file path="uno.config.ts">
// uno.config.ts
import {defineConfig, presetUno, transformerVariantGroup} from "unocss";
import transformerDirectives from "@unocss/transformer-directives";

export default defineConfig({
  theme: {
    fontFamily: {
      sans: "Montserrat",
    },
    colors: {
      surface: "hsl(var(--clrSurface))",
      base: "hsl(var(--clrBase))",
      primary: "hsl(var(--clrPrimary))",
      secondary: "hsl(var(--clrSecondary))",
      tertiary: "hsl(var(--clrTertiary))",
    },
  },
  presets: [presetUno()],
  transformers: [transformerVariantGroup(), transformerDirectives({})],
  rules: [
    [
      /^grid-col-fill-(\d+)$/,
      ([, d]) => ({
        "grid-template-columns": `repeat( auto-fit, minmax(${d}px, 1fr) );`,
      }),
    ],
    [
      /^scrollbar-hide$/,
      ([_]) => {
        return `.scrollbar-hide{scrollbar-width:none}
.scrollbar-hide::-webkit-scrollbar{display:none}`;
      },
    ],
    [
      /^scrollbar-default$/,
      ([_]) => {
        return `.scrollbar-default{scrollbar-width:auto}
.scrollbar-default::-webkit-scrollbar{display:block}`;
      },
    ],
    [
      // https://unocss.dev/config/theme#usage-in-rules
      /^text-(.*)$/,
      // @ts-ignore
      ([, c], {theme}) => {
        if (theme.colors && theme.colors[c]) return {color: theme.colors[c]};
      },
    ],
    // [
    //   /^fill-(.*)$/,
    //   // @ts-ignore
    //   ([, c], {theme}) => {
    //     if (theme.colors && theme.colors[c]) return {fill: theme.colors[c]};
    //   },
    // ],
    // [
    //   /^stroke-(.*)$/,
    //   // @ts-ignore
    //   ([, c], {theme}) => {
    //     if (theme.colors && theme.colors[c]) return {stroke: theme.colors[c]};
    //   },
    // ],
    [
      // https://unocss.dev/config/theme#usage-in-rules
      /^bglg-(.*(?=\)$))/,
      ([, c]) => {
        return {
          "background-image": `linear-gradient(${c.replaceAll("_", " ")})`,
        };
      },
    ],
    [
      // https://unocss.dev/config/theme#usage-in-rules
      /^bg-(.*)$/,
      // @ts-ignore
      ([, c], {theme}) => {
        if (theme.colors && theme.colors[c]) {
          return {"background-color": theme.colors[c]};
        }
      },
    ],
  ],
});
</file>

<file path="public/_headers">
# fonts 1 month (max max-age)
/*.woff
  Cache-Control: public, max-age=2629746, s-maxage=31536000, must-revalidate

/*.woff2
  Cache-Control: public, max-age=2629746, s-maxage=31536000, must-revalidate

# player url: 1 day browser, 1 year cdn
https://players.brightcove.net/6314154063001/9mlrvmAybr_default/index.min.js
Cache-Control: public, max-age=86400, s-maxage=31536000, must-revalidate

# CSS is hashed,  so it's safe to cache for year at a time
/_astro/*.css
Cache-Control: public, max-age=31536000, s-maxage=31536000, must-revalidate

# JS is hashed, so it's safe to cache for year at a time
/_astro/*.js
Cache-Control: public, max-age=31536000, s-maxage=31536000, must-revalidate
</file>

<file path="src/components/DownloadForm/DownloadRadio.tsx">
import {RadioGroup} from "@kobalte/core";
import {For} from "solid-js";

interface IDownloadRadio {
  formName: string;
  defaultValue: string;
  onValueChange: (arg: string) => void;
  radioLabel: string;
  radioOptions: Array<{
    text: string;
    value: string;
  }>;
}
export function DownloadRadio(props: IDownloadRadio) {
  return (
    <RadioGroup.Root
      data-testid="download-scope-radio-group"
      class="radio-group"
      name={props.formName}
      defaultValue={props.defaultValue}
      onChange={(val) => props.onValueChange(val)}
    >
      <RadioGroup.Label class="radio-group__label">
        {props.radioLabel}
      </RadioGroup.Label>
      <div class="">
        <For each={props.radioOptions}>
          {(opt) => (
            <RadioGroup.Item data-testid={`download-scope-${opt.value}`} value={opt.value} class="flex gap-2">
              <RadioGroup.ItemInput class="radio__input" />
              <RadioGroup.ItemControl class="w-6 h-6 rounded-full bg-surface/20 grid place-content-center relative p-2">
                <RadioGroup.ItemIndicator class="absolute w-3/5 h-3/5 inset-20% rounded-full block bg-primary" />
              </RadioGroup.ItemControl>
              <RadioGroup.ItemLabel class="radio__label">
                {opt.text}
              </RadioGroup.ItemLabel>
            </RadioGroup.Item>
          )}
        </For>
      </div>
    </RadioGroup.Root>
  );
}
</file>

<file path="src/components/PlayerNavigation/ChapterButton.tsx">
import type {IVidWithCustom} from "@customTypes/types";
import {updateHistory} from "@lib/UI";

interface IChapterButton {
  onClick: (vid: IVidWithCustom) => void;
  vid: IVidWithCustom;
  currentVid: IVidWithCustom;
}
export function ChapterButton(props: IChapterButton) {
  return (
    <button
      data-testid={`chapter-button-${props.vid.chapter}`}
      onClick={() => {
        props.onClick(props.vid);
        updateHistory(props.vid, "PUSH");
      }}
      class={`rounded-full h-8 w-8 inline-grid place-content-center text-center flex-shrink-0 bg-neutral-400 dark:bg-neutral-600 text-white sm:(w-12 h-12) hover:(bg-primary/70 transition scale-110) active:(scale-95) ${
        props.vid.chapter === props.currentVid.chapter
          ? "bg-neutral-800 dark:bg-neutral-900 transform scale-120  transition-colors duration-200"
          : ""
      }`}
    >
      {Number(props.vid.chapter)}
    </button>
  );
}
</file>

<file path="src/components/I18nWrapper.tsx">
// import type {i18nDictWithLangCode} from "@customTypes/types";
// // import { I18nContext, createI18nContext } from "@solid-primitives/i18n";
// import * as translator from "@solid-primitives/i18n";
// import type {JSX} from "solid-js";

// interface i18Props {
//   locale: string;
//   children: JSX.Element;
//   initialDict: i18nDictWithLangCode;
// }
// export function I18nProvider(props: i18Props) {
//   // eslint-disable-next-line solid/reactivity
//   const value = createI18nContext(props.initialDict, props.locale);
//   return (
//     <I18nContext.Provider value={value}>{props.children}</I18nContext.Provider>
//   );
// //
</file>

<file path="src/i18n/fr.ts">
import type {BaseLang} from "./en";

const lang: BaseLang = {
  about: "A propos",
  bibleSelection: "Sélection de la Bible",
  chooseABook: "Choisissez un livre de la Bible à regarder ici.",
  homePage: "Page d'accueil",
  license: "Licence",
};
export default lang;
</file>

<file path="src/lib/store.ts">
import {createSignal} from "solid-js";
import {createStore} from "solid-js/store";
import type {IDownloadPreferences, IVidWithCustom} from "@customTypes/types";
import type Player from "video.js/dist/types/player";

const [downloadPreference, setDownloadPreference] =
  createSignal<IDownloadPreferences>({
    saveToServiceWorker: false,
    downloadOffline: true,
    justThisVideo: true,
    swPayload:
      null /* arr of vid {name, refid, src, size} objects that sw can digest */,
  });
// SSR will populate this when it renders.
const [currentVid, setCurrentVid] = createStore<IVidWithCustom>(
  {} as IVidWithCustom
);
const [currentPlaylist, setCurrentPlaylist] =
  createSignal<Record<string | number | symbol, IVidWithCustom[]>>();
const [vidProgress, setVidProgress] = createSignal(0);
const [currentBook, setCurrentBook] = createSignal<IVidWithCustom[]>();
const [currentChapLabel, setCurrentChapLabel] = createSignal("");
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const [vjsPlayer, setVjsPlayer] = createSignal<Player>();
const [showDownloadMenu, setShowDownloadMenu] = createSignal(false);
const [playerSpeed, setPlayerSpeed] = createSignal<string>();

export {
  vidProgress,
  setVidProgress,
  downloadPreference,
  setDownloadPreference,
  currentVid,
  setCurrentVid,
  currentBook,
  setCurrentBook,
  currentChapLabel,
  setCurrentChapLabel,
  vjsPlayer,
  setVjsPlayer,
  showDownloadMenu,
  setShowDownloadMenu,
  playerSpeed,
  setPlayerSpeed,
  currentPlaylist,
  setCurrentPlaylist,
};
</file>

<file path="src/licenses/benin.md">
# Licence
Traduction en langue des signes du Bénin ©2023 La Bible en Toutes Langues Communauté de Missions.
Publié sous une licence internationale Creative Commons Attribution-Share Alike 4.0.

La traduction est basée sur la Bible Louis Segond 1910 du domaine public, disponible sur [https://bibleineverylanguage.org](https://bibleineverylanguage.org)
Pour en savoir plus sur la licence Creative Commons, visitez le site [https://creativecommons.org/licenses/by-sa/4.0/deed.fr](https://creativecommons.org/licenses/by-sa/4.0/deed.fr)
</file>

<file path="src/licenses/bukavu.md">
# Tafsiri ya Biblia katika Lugha ya Ishara ya Kiswahili

©2025 Biblia katika Kila Jumuiya ya Misheni ya Lugha
Imetolewa chini ya Creative Commons Attribution-Shiriki Sawa 4.0 Leseni ya Kimataifa.
Tafsiri hii inatokana na Biblia ya Kiswahili Iliyofunguliwa na Wycliffe Associates, CC BY-SA 4.0, inayopatikana katika https://bibleineverylanguage.org/translations.
Kwa maelezo zaidi kuhusu Leseni ya Creative Commons tembelea https://creativecommons.org/licenses/by-sa/4.0/.
</file>

<file path="src/licenses/cameroon.md">
# Cameroonian Anglophone Sign Language New Testament
©2023 Bible in Every Language Missions Community
Released under a Creative Commons Attribution-Share Alike 4.0 International License.

This translation is based on the English Unlocked Literal Bible by Wycliffe Associates, CC BY-SA 4.0, available at [https://bibleineverylanguage.org/translations](https://bibleineverylanguage.org/translations).
For more information about the Creative Commons License visit [https://creativecommons.org/licenses/by-sa/4.0/](https://creativecommons.org/licenses/by-sa/4.0/).
</file>

<file path="src/licenses/congoFrench.md">
# Congolese French Sign Language 

Republique Democratique du Congo. La Traduction de la Bible en Langue des signes. 

© 2025 La Bible dans toutes les langues Communauté de Missions. 

Ce travail est publié sous une licence Creative Commons Attribution-ShareAlike 4.0 International. 

Pour en savoir plus sur la licence Creative Commons, visitez le site [https://creativecommons.org/licenses/by-sa/4.0/deed.fr](https://creativecommons.org/licenses/by-sa/4.0/deed.fr)

La traduction est basée sur la Bible Louis Segond 1910 du domaine public, disponible sur [https://bibleineverylanguage.org](https://bibleineverylanguage.org).
</file>

<file path="src/pages/api/getPlaylist.ts">
import {playbackApi} from "@customTypes/Api";
import type {APIRoute} from "astro";

export const GET: APIRoute = async (context) => {
  const runtime = context.locals.runtime;
  const env = runtime.env;
  const url = context.url;
  const playlist = url.searchParams?.get("playlist") as string;
  const policyKey = env.POLICY_KEY;
  const accountId = env.ACCOUNT_ID;

  if (!playlist) {
    return new Response(null, {
      status: 400,
      statusText: "Missing parameters",
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  }

  try {
    const pbApi = new playbackApi({
      baseUrl: "https://edge.api.brightcove.com/playback/v1",
      baseApiParams: {
        headers: {
          Accept: `application/json;pk=${policyKey}`,
        },
      },
    });

    const res = await pbApi.accounts.getPlaylistsByIdOrReferenceId(
      accountId,
      `ref:${playlist}`,
      {
        limit: 2000,
      }
    );
    if (res.ok) {
      return new Response(JSON.stringify(res.data), {
        headers: {
          "Access-Control-Allow-Origin": "*",
        },
      });
    } else {
      return new Response(null, {
        status: 404,
      });
    }
  } catch (error) {
    console.error(error);
    return new Response(null, {
      status: 400,
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  }
};
</file>

<file path="tests/e2e/navigation.spec.ts">
import {expect, test} from "@playwright/test";
import {
  navigateToBook,
  navigateToChapter,
  TEST_BOOKS,
  TEST_CHAPTERS,
  verifyURLPattern,
  waitForVideoPlayer,
} from "../fixtures/test-helpers";

test.describe("Navigation Tests", () => {
  test.beforeEach(async ({page}) => {
    await page.goto("/");
    await waitForVideoPlayer(page);
  });

  test("navigate between books in the Bible", async ({page}) => {
    // Start with first book (should be default)
    await expect(page.getByTestId("book-button-mat")).toBeVisible();

    // Navigate to different books
    for (const book of TEST_BOOKS) {
      await navigateToBook(page, book);

      // Verify URL is updated correctly (includes first chapter)
      await expect(page).toHaveURL(new RegExp(`/${book}\\..+`, "i"));

      // Verify book button is highlighted (active state)
      await expect(
        page.getByTestId(`book-button-${book.toLowerCase()}`)
      ).toHaveClass(/underline/);

      // Verify chapters load for this book
      const chapterButtons = page.getByTestId(/^chapter-button-/);
      await expect(chapterButtons.first()).toBeVisible();
    }
  });

  test("navigate between chapters within books", async ({page}) => {
    // Navigate to Matthew first
    await navigateToBook(page, "MAT");

    // Navigate to different chapters
    for (const chapter of TEST_CHAPTERS) {
      await navigateToChapter(page, chapter);

      // Verify URL is updated correctly (chapter as three-digit number)
      await expect(page).toHaveURL(new RegExp(`/MAT\\.${chapter}$`, "i"));

      // Verify chapter button exists and is clickable
      await expect(page.getByTestId(`chapter-button-${chapter}`)).toBeVisible();
    }
  });

  test("dynamic routing works correctly for book/chapter/verse patterns", async ({
    page,
  }) => {
    // Test various URL patterns

    // Direct navigation to book only (will default to chapter 1)
    await page.goto("/LUK");
    await waitForVideoPlayer(page);
    await expect(page).toHaveURL(/\/LUK\.\d+$/);
    await expect(page.getByTestId("book-button-luk")).toHaveClass(/underline/);

    // Direct navigation to book and chapter
    await page.goto("/JHN.3");
    await waitForVideoPlayer(page);
    await expect(page.getByTestId("book-button-jhn")).toHaveClass(/underline/);
    await expect(page.getByTestId("chapter-button-003")).toHaveClass(
      /scale-120/
    );

    // Direct navigation to book, chapter, and verse
    await page.goto("/ACT.2.15");
    await waitForVideoPlayer(page);
    await expect(page.getByTestId("book-button-act")).toHaveClass(/underline/);
    await expect(page.getByTestId("chapter-button-002")).toHaveClass(
      /scale-120/
    );
  });

  test("browser back/forward navigation works", async ({page}) => {
    // Test basic back/forward functionality
    await page.goto("/");
    await waitForVideoPlayer(page);

    // Navigate to a book (using MRK which exists in mock data)
    await page.goto("/MRK.3");
    await waitForVideoPlayer(page);

    // Navigate to another book (using LUK which exists in mock data)
    await page.goto("/LUK.3");
    await waitForVideoPlayer(page);

    // Go back
    await page.goBack();
    await expect(page).toHaveURL(/\/MRK/);

    // Go forward
    await page.goForward();
    await expect(page).toHaveURL(/\/LUK/);
  });

  test("URL updates correctly as user navigates", async ({page}) => {
    // Start at home
    await page.goto("/");
    await waitForVideoPlayer(page);

    // Navigate to a specific book (defaults to chapter 1)
    await navigateToBook(page, "MAT");
    await expect(page).toHaveURL(/\/MAT\.\d+$/);

    await navigateToChapter(page, "005");
    await expect(page).toHaveURL(/\/MAT\.005$/);

    // Navigate to another book (resets to chapter 1)
    await navigateToBook(page, "LUK");
    await expect(page).toHaveURL(/\/LUK\.\d+$/);

    // Navigate to chapter in new book
    await navigateToChapter(page, "010");
    await expect(page).toHaveURL(/\/LUK\.010$/);
  });

  test("chapter navigation updates correctly when switching books", async ({
    page,
  }) => {
    // Navigate to Matthew chapter 5
    await navigateToBook(page, "MAT");
    await navigateToChapter(page, "005");
    await expect(page.getByTestId("chapter-button-005")).toBeVisible();

    // Switch to John - should reset to first chapter
    await navigateToBook(page, "JHN");
    await expect(page.getByTestId("book-button-jhn")).toHaveClass(/underline/);

    // Should see chapter buttons for John (starting with chapter 1)
    const firstChapterBtn = page.getByTestId("chapter-button-001");
    await expect(firstChapterBtn).toBeVisible();

    // Verify URL (defaults to chapter 1)
    await expect(page).toHaveURL(/\/JHN\.\d+$/);
  });

  test("home link works from book/chapter pages", async ({page}) => {
    // Navigate to a specific book and chapter
    await page.goto("/MAT.10");
    await waitForVideoPlayer(page);

    // Open menu
    await page.getByTestId("header-menu-toggle").click();

    // Wait for menu to be fully open (wait for close button to appear)
    await page.getByTestId("header-menu-close").waitFor({state: "visible"});

    // Navigate to home directly instead of clicking link
    await page.goto("/");

    // Should be on home page
    await expect(page).toHaveURL("/");
    await waitForVideoPlayer(page);
  });
});
</file>

<file path="tests/handlers.ts">
import {fileURLToPath} from "node:url";
import {readFileSync} from "fs";
import {HttpResponse, http} from "msw";
import {dirname, join} from "path";

// Load mock data
const __dirname = dirname(fileURLToPath(import.meta.url));
const mockDataPath = join(__dirname, "./mockData/bc-response.json");
const bcResponseMock = JSON.parse(readFileSync(mockDataPath, "utf-8"));

// Create handlers for API calls
export const handlers = [
  // Mock getPlaylist API call
  http.get("http://localhost:4321/api/getPlaylist", () => {
    return new HttpResponse(JSON.stringify(bcResponseMock), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  }),

  // Mock getId API call
  http.get("http://localhost:4321/api/getId", () => {
    return new HttpResponse(
      JSON.stringify({
        accountId: "6314154063001",
        playerId: "9mlrvmAybr",
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      }
    );
  }),
];
</file>

<file path="src/components/PlayerNavigation/DownloadMenu.tsx">
import {DownloadSwitch} from "@components/DownloadForm/DownloadSwitch";
import {DownloadRadio} from "@components/DownloadForm/DownloadRadio";
import {HiddenForm} from "@components/DownloadForm/HiddenForm";
import {WholeDownloadSelect} from "@components/DownloadForm/DownloadSelect";

import {downloadPreference, setDownloadPreference} from "@lib/store";
import {Show} from "solid-js";
import type {wholeBookPresets} from "@customTypes/types";
import {SingleDownloadSelect} from "@components/DownloadForm/DownloadSelect";
import {
  currentMp4Sources,
  wholeBooksOptionsForSelect,
  populateSwPayload,
} from "@lib/UI";

interface IDownloadMenu {
  formDataRef: HTMLFormElement | undefined;
  formName: string;
}
export function DownloadMenu(props: IDownloadMenu) {
  return (
    <>
      <form
        data-testid="download-form"
        action="/"
        name="downloadData"
        id="downloadDataForm"
        ref={props.formDataRef}
        class="flex flex-col gap-2"
      >
        <DownloadRadio
          formName={props.formName}
          defaultValue="chapter"
          onValueChange={(val) =>
            setDownloadPreference((prev) => {
              return {
                ...prev,
                swPayload: null,
                justThisVideo: val == "book" ? false : true,
              };
            })
          }
          radioLabel="Download Scope"
          radioOptions={[
            {text: "Whole Book", value: "book"},
            {text: "Just this video", value: "chapter"},
          ]}
        />

        <Show when={downloadPreference().justThisVideo}>
          <div class="relative z-10">
            <SingleDownloadSelect
              formName={props.formName}
              placeholder="Select video quality"
              selectOptions={currentMp4Sources()!}
              onValueChange={(val) => populateSwPayload({type: "VID", val})}
            />
          </div>
        </Show>

        <Show when={!downloadPreference().justThisVideo}>
          <div class="relative z-10">
            <WholeDownloadSelect
              formName={props.formName}
              placeholder="Select playlist quality"
              selectOptions={wholeBooksOptionsForSelect()!}
              onValueChange={(val: wholeBookPresets) =>
                populateSwPayload({type: "BOOK", val})
              }
            />
          </div>
        </Show>

        <DownloadSwitch
          formName={props.formName}
          defaultIsChecked={downloadPreference().downloadOffline}
          onCheckedChange={(isChecked) =>
            setDownloadPreference((prev) => {
              return {
                ...prev,
                downloadOffline: isChecked,
              };
            })
          }
          switchLabel=" Download To Device"
        />

        <DownloadSwitch
          formName={props.formName}
          defaultIsChecked={downloadPreference().saveToServiceWorker}
          onCheckedChange={(isChecked) =>
            setDownloadPreference((prev) => {
              return {
                ...prev,
                saveToServiceWorker: isChecked,
              };
            })
          }
          switchLabel="Save offline"
        />
      </form>
      <HiddenForm name={props.formName} />
    </>
  );
}
</file>

<file path="src/i18n/en.ts">
export const lang = {
  about: "About",
  bibleSelection: "Bible Selection",
  chooseABook: "Choose a book of the Bible to watch here.",
  homePage: "Home",
  license: "License",
};
export type BaseLang = typeof lang;
export default lang;
</file>

<file path="src/components/DownloadForm/DownloadSelect.tsx">
import {Select} from "@kobalte/core/select";
import {Show} from "solid-js";
import type {customVideoSources, wholeBookPresets} from "@customTypes/types";
import {bytesToMb} from "@lib/utils";

interface ICommonSelect {
  formName: string;
  placeholder: string;
}

interface IWholeBookSelect extends ICommonSelect {
  selectOptions: {
    size: string;
    totalSize: number;
    wholeBooksOptionsForSelectId: wholeBookPresets;
  }[];
  onValueChange: (arg: wholeBookPresets) => void;
}
export function WholeDownloadSelect(props: IWholeBookSelect) {
  type OptionGeneric = (typeof props.selectOptions)[number];
  return (
    <Show when={props.selectOptions}>
      <Select
        data-testid="download-quality-whole-book"
        // name="downloads"
        name={props.formName}
        flip={false}
        hideWhenDetached={true}
        options={props.selectOptions}
        onChange={(val) => {
          // const coerced = val as wholeBookPresets;
          props.onValueChange(val?.size as wholeBookPresets);
        }}
        optionValue={(val) => val.wholeBooksOptionsForSelectId}
        optionTextValue={(val) => `${val.size}`}
        placeholder={props.placeholder}
        itemComponent={(opt) => (
          <Select.Item
            item={opt.item}
            class={`text-surface  data-[selected]:text-primary/80 hover:bg-primary/20 px-2`}
          >
            <Select.ItemLabel>
              {bytesToMb(opt.item.rawValue.totalSize)} MB
            </Select.ItemLabel>
          </Select.Item>
        )}
      >
        <Select.Trigger
          aria-label="Mp4 Quality"
          class="inline-flex items-center justify-between w-60 rounded-md py-2 pl-2 pr-4 text-surface/90 bg-surface/10 border border-surface/20 hover:border-surface/30 transition-colors duration-150"
        >
          <Select.Value<OptionGeneric> class="text-ellipsis whitespace-nowrap overflow-hidden data-[placeholder-shown]:text-surface/80">
            {(state) =>
              `${state.selectedOption().size}-${bytesToMb(
                state.selectedOption().totalSize
              )} MB`
            }
          </Select.Value>
          <Select.Icon class="text-surface/90 w-6 h-6">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="100%"
              height="100%"
              viewBox="0 0 256 256"
            >
              <path
                fill="currentColor"
                d="M181.66 170.34a8 8 0 0 1 0 11.32l-48 48a8 8 0 0 1-11.32 0l-48-48a8 8 0 0 1 11.32-11.32L128 212.69l42.34-42.35a8 8 0 0 1 11.32 0Zm-96-84.68L128 43.31l42.34 42.35a8 8 0 0 0 11.32-11.32l-48-48a8 8 0 0 0-11.32 0l-48 48a8 8 0 0 0 11.32 11.32Z"
              />
            </svg>
          </Select.Icon>
        </Select.Trigger>
        {/* <Select.Portal> */}
        <Select.Content class={`text-surface/90  bg-base border static!`}>
          <Select.Listbox class="py-4 max-h-[300px] overflow-y-auto" />
        </Select.Content>
        {/* </Select.Portal> */}
      </Select>
    </Show>
  );
}

interface ISingleVidSelect extends ICommonSelect {
  selectOptions: customVideoSources[];
  onValueChange: (arg: string) => void;
}
export function SingleDownloadSelect(props: ISingleVidSelect) {
  type OptionGeneric = (typeof props.selectOptions)[number];

  return (
    <Show when={props.selectOptions}>
      <Select<OptionGeneric>
        data-testid="download-quality-single-video"
        // name="downloads"
        name={props.formName}
        flip={false}
        hideWhenDetached={true}
        options={props.selectOptions}
        defaultValue={props.selectOptions[0]}
        onChange={(val) => props.onValueChange(String(val?.size))}
        optionValue={(val) => String(val.size)}
        optionTextValue={(val) => `${String(bytesToMb(val?.size))}`}
        placeholder={props.placeholder}
        optionDisabled={() => false}
        itemComponent={(opt) => (
          <Select.Item
            item={opt.item}
            class={`text-surface  data-[selected]:text-primary/80 hover:bg-primary/20 px-2`}
          >
            <Select.ItemLabel>
              {bytesToMb(opt.item.rawValue.size)} MB
            </Select.ItemLabel>
          </Select.Item>
        )}
      >
        <Select.Trigger
          aria-label="Mp4 Quality"
          class="inline-flex items-center justify-between w-60 rounded-md py-2 pl-2 pr-4 text-surface/90 bg-surface/10 border border-surface/20 hover:border-surface/30 transition-colors duration-150"
        >
          <Select.Value<OptionGeneric> class="text-ellipsis whitespace-nowrap overflow-hidden data-[placeholder-shown]:text-surface/80">
            {(state) => `${state.selectedOption().size} MB`}
          </Select.Value>

          <Select.Icon class="text-surface/90 w-6 h-6">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="100%"
              height="100%"
              viewBox="0 0 256 256"
            >
              <path
                fill="currentColor"
                d="M181.66 170.34a8 8 0 0 1 0 11.32l-48 48a8 8 0 0 1-11.32 0l-48-48a8 8 0 0 1 11.32-11.32L128 212.69l42.34-42.35a8 8 0 0 1 11.32 0Zm-96-84.68L128 43.31l42.34 42.35a8 8 0 0 0 11.32-11.32l-48-48a8 8 0 0 0-11.32 0l-48 48a8 8 0 0 0 11.32 11.32Z"
              />
            </svg>
          </Select.Icon>
        </Select.Trigger>
        {/* <Select.Portal> */}
        <Select.Content class={`text-surface/90  bg-base border`}>
          <Select.Listbox class="py-4 max-h-[300px] overflow-y-auto" />
        </Select.Content>
        {/* </Select.Portal> */}
      </Select>
    </Show>
  );
}
</file>

<file path="src/components/DownloadForm/HiddenForm.tsx">
import { DOWNLOAD_SERVICE_WORK_URL } from "@lib/routes";
import { downloadPreference } from "@lib/store";
import { Show } from "solid-js";

interface IHiddenForm {
	name: string;
}
export function HiddenForm(props: IHiddenForm) {
	return (
		<form action={DOWNLOAD_SERVICE_WORK_URL} method="post" name={props.name}>
			<input
				type="hidden"
				name="swPayload"
				value={JSON.stringify(downloadPreference().swPayload)}
			/>
			<input
				type="hidden"
				name="swDownloadDevice"
				value={String(downloadPreference().downloadOffline)}
			/>
			<input
				type="hidden"
				name="swSaveSw"
				value={String(downloadPreference().saveToServiceWorker)}
			/>
			<Show
				when={
					(downloadPreference().saveToServiceWorker ||
						downloadPreference().downloadOffline) &&
					downloadPreference().swPayload
				}
			>
				<button
					type="submit"
					class="dark:(bg-surface/10 border border-primary/60 hover:(border-primary/90 bg-surface/20)) hover:(bg-neutral-300) active:(scale-98) px-4 py-2 rounded mt-2 bg-neutral-200 border border-primary"
				>
					Submit
				</button>
			</Show>
		</form>
	);
}
</file>

<file path="src/components/Icons.tsx">
import dotLogoDark from "@src/images/dotLogos/No_background_plain.webp";
import { type Accessor } from "solid-js";

interface IconProps {
	classNames?: string;
}

export function DotLogo() {
	return <img src={dotLogoDark.src} width="192" alt="" />;
}
export function DotLogoHandsOnly(props: IconProps) {
	<svg
		xmlns="http://www.w3.org/2000/svg"
		width="1080"
		height="1080"
		viewBox="5.07 5.07 1080 1080"
		xml-space="preserve"
		class={props.classNames || ""}
	>
		<g transform="matrix(1.35 0 0 -1.35 540 540)" clip-path="url(#a)">
			<clipPath id="a">
				<path
					transform="translate(-656.26 -541.37)"
					d="M0 1080h1920V0H0Z"
					stroke-linecap="round"
				/>
			</clipPath>
			<path
				style={{
					stroke: "none",
					"stroke-width": "1",
					"stroke-dasharray": "none",
					"stroke-linecap": "butt",
					"stroke-dashoffset": "0",
					"stroke-linejoin": "miter",
					"stroke-miterlimit": "4",
					fill: "#981414",
					"fill-rule": "nonzero",
					opacity: "1",
				}}
				vector-effect="non-scaling-stroke"
				transform="translate(-33.94 6.8)"
				d="M0 0h-4.555c-3.314.003-6.628.054-9.942.001-5.839-.095-11.255-5.606-11.261-11.4-.004-4.35.032-8.7-.011-13.05-.02-2.071.476-3.965 1.599-5.688 2.521-3.868 6.133-6.12 10.712-6.015 6.267.144 11.945 5.912 11.93 12.56-.011 5.109-.011 10.219-.073 15.328-.027 2.235.155 4.394 1.185 6.433C-.163-1.33-.152-.706 0 0m52.84-7.983c.286-.483.401-.821.629-1.041 3.173-3.071 6.38-6.107 9.543-9.188 4.435-4.319 10.755-4.879 15.389-.847 3.896 3.391 7.536 7.124 10.951 11.003 2.07 2.352 3.128 5.392 2.41 8.682-.684 3.129-2.189 5.836-4.763 7.794-3.062 2.329-6.447 3.28-10.311 2.213-2.704-.746-4.852-2.276-6.784-4.193A2560.187 2560.187 0 0 1 59.35-4.109c-1.585-1.593-3.336-2.892-5.583-3.393-.251-.056-.473-.241-.927-.481m-78.508 40.197c.362-.03.716-.147 1.023-.071 3.702.921 7.443 1.375 11.266 1.171 1.471-.078 1.685.243 1.683 1.894-.023 16.712-.045 33.424-.079 50.136-.001.755.003 1.54-.19 2.258-1.846 6.845-10.137 11.937-17.426 5.644a17 17 0 0 1-1.612-1.609c-.919-1.04-.901-1.285.03-2.23 3.458-3.507 5.269-7.722 5.256-12.648-.04-14.568-.127-29.136-.184-43.704-.001-.259.14-.518.233-.841m-20.781-11.843c.854.476 1.339.613 1.632.929 2.772 2.982 6.132 5.223 9.739 6.925 2.487 1.174 3.261 2.497 3.222 5.281-.197 14.022-.089 28.048-.12 42.072a21.25 21.25 0 0 1-.381 3.905c-1.063 5.592-7.334 9.416-12.769 7.939-3.131-.851-5.373-2.692-6.931-5.485-1.154-2.067-1.104-2.279.561-3.842 3.618-3.395 5.334-7.636 5.397-12.565.019-1.45-.055-2.9-.056-4.35-.01-12.228-.007-24.457-.03-36.685-.002-1.211-.151-2.421-.264-4.124M70.905-54.8c-.91.069-1.245.131-1.577.115a30.368 30.368 0 0 0-13.334 2.323c-1.169.486-1.887.233-2.719-.622-3.562-3.657-7.176-7.264-10.781-10.879-7.064-7.085-14.136-14.161-21.203-21.243-1.686-1.69-3.07-3.603-3.437-6.003-.678-4.447.951-8.04 4.564-10.613 3.579-2.55 7.015-2.717 10.692-.759.843.448 1.188.989 1.043 1.98-.47 3.19.282 6.23 1.783 8.977 1.007 1.845 2.41 3.545 3.906 5.039 9.957 9.944 19.991 19.81 29.976 29.726.422.419.609 1.077 1.087 1.959m-22.521 5.695c-.28.267-.442.503-.667.621a31.96 31.96 0 0 0-9.191 7.285c-.953 1.09-1.229 1.051-2.313-.041C29.506-48 22.807-54.768 16.089-61.517A4481.231 4481.231 0 0 0 1.297-76.298c-1.902-1.894-3.345-4.048-3.754-6.744-1.118-7.353 6.01-12.832 11.422-12.172 2.38.291 2.64.348 2.709 2.641.135 4.475 1.695 8.345 4.847 11.533 1.648 1.666 3.389 3.24 5.05 4.894 8.657 8.618 17.303 17.247 25.944 25.881.322.322.554.734.869 1.16M-51.76-.482l-.64.078c.046 1.058.126 2.115.134 3.172.044 5.867.102 11.735.095 17.602-.013 10.357-.073 20.714-.104 31.072-.013 4.627.084 9.257-.052 13.881-.048 1.613-.37 3.34-1.048 4.79-2.089 4.472-7.164 6.924-11.667 5.887-5.093-1.172-8.51-5.377-8.521-10.58-.021-10.084.001-20.167-.011-30.251-.026-22.378-.093-44.756-.052-67.134.005-2.811.379-5.653.891-8.423 1.286-6.952 4.087-13.3 8.143-19.087 5.576-7.957 12.904-13.757 21.831-17.52 6.445-2.717 13.182-3.911 20.19-3.765 4.601.097 9.036.932 13.406 2.298 1.271.397 2.095 1.194 2.811 2.275.834 1.257 1.708 2.527 2.767 3.59a6085.926 6085.926 0 0 0 25.811 25.759c1.174 1.166 1.985 2.488 2.208 4.115.524 3.824.951 7.662 1.513 11.48.239 1.618-.32 2.764-1.446 3.857-2.627 2.548-5.165 5.187-7.765 7.764-5.07 5.023-6.507 14.164-2.065 20.585.313.452.455 1.023.734 1.673-2.325.462-3.964-.48-5.525-1.455C6.365-1.014 4.347-4.11 4.375-8.388c.035-5.18.009-10.361.021-15.541.026-11.141-9.748-19.699-20.754-18.064-8.715 1.295-15.107 8.052-15.575 16.786-.144 2.682-.072 5.376-.068 8.065.003 2.344-.147 4.71.113 7.028.767 6.859 4.985 13.023 12.411 15.308 2.814.866 5.682.937 8.595.916 9.043-.064 18.088.019 27.131-.091 2.231-.027 4.199.488 6.123 1.492 4.024 2.1 6.476 7.11 5.505 11.311-1.135 4.916-5.788 8.628-10.846 8.629-10.773.001-21.547-.008-32.321-.017-.551-.001-1.108-.006-1.653-.076-6.581-.846-12.837-2.632-18.385-6.431-7.073-4.845-12.489-11.017-15.397-19.208-.27-.76-.686-1.469-1.035-2.201M90.208-44.087l.364-.432c-1.316-1.292-2.644-2.572-3.945-3.88C75.426-59.66 64.23-70.928 53.032-82.193c-3.263-3.281-6.562-6.526-9.781-9.85-4.004-4.136-4.04-9.023-.823-13.53 2.443-3.423 7.349-5.017 11.374-3.796 2.117.641 3.802 1.898 5.336 3.433 9.423 9.427 18.845 18.855 28.284 28.265 13.106 13.068 26.254 26.093 39.329 39.192 5.742 5.752 9.993 12.466 12.425 20.278 2.031 6.523 3.029 13.128 2.175 19.987-.55 4.414-1.481 8.717-3.133 12.823-3.331 8.281-8.328 15.357-15.413 20.92-5.848 4.592-12.333 7.81-19.552 9.541-5.417 1.298-10.907 1.593-16.45 1.057a46.903 46.903 0 0 1-12.832-3.077c-6.964-2.761-13.026-6.865-18.265-12.243-5.012-5.144-10.143-10.172-15.223-15.25-2.208-2.207-3.444-4.883-3.304-7.99.199-4.418 2.625-7.514 6.509-9.354 3.958-1.875 7.749-1.186 10.928 1.756 3.698 3.421 7.323 6.937 10.77 10.609 4.594 4.894 10.113 6.986 16.739 6.226 4.662-.535 8.526-2.573 11.554-6.198 5.756-6.89 5.609-17.886-1.073-24.562-2.833-2.831-5.657-5.672-8.504-8.489-2.203-2.178-4.789-3.906-7.778-4.557-6.963-1.514-13.275-.264-18.484 5.035-6.439 6.55-12.958 13.022-19.455 19.515-1.024 1.024-2.028 2.099-3.188 2.95-3.447 2.531-7.229 3.205-11.062 1.084-4.032-2.232-6.366-5.654-6.052-10.478.17-2.621 1.501-4.688 3.305-6.495 7.565-7.574 15.087-15.191 22.726-22.689 1.857-1.822 3.996-3.416 6.19-4.826 8.243-5.298 17.318-7.031 26.947-5.651 4.097.587 8.113 1.683 11.693 3.945.38.24.84.353 1.264.525M-8.723-84.715c-.77-.162-1.178-.212-1.564-.334-3.993-1.26-8.098-1.604-12.262-1.633-4.567-.032-9.096.133-13.577 1.169-6.309 1.458-12.224 3.76-17.705 7.271-11.462 7.341-19.137 17.559-23.356 30.409-1.183 3.601-2.006 7.314-2.078 11.156-.063 3.306-.348 6.61-.352 9.915-.039 30.047-.039 60.094-.047 90.142-.001 1.918-.219 3.818.214 5.751 1.569 6.997 6.018 11.204 12.744 13.002 1.94.518 4.128.295 6.182.136 1.473-.114 1.829.185 2.306 1.384 3.007 7.561 10.916 11.752 18.801 9.94 1.363-.313 2.155-.045 2.947 1.102 3.11 4.502 7.322 7.251 12.874 7.675 3.546.271 6.877-.554 9.896-2.386 4.223-2.564 6.831-6.352 7.939-11.159.153-.663.178-1.368.177-2.053-.009-7.944-.018-15.887-.06-23.831-.049-9.176-.131-18.352-.2-27.528-.014-1.838.289-2.122 2.167-2.111 7.316.042 14.634.203 21.946.073 6.576-.117 11.102-3.686 14.09-9.325.825-1.558 1.651-3.213 1.262-5.129-.042-.208.197-.474.385-.887.465.32.88.523 1.188.832 6.434 6.453 12.709 13.073 19.323 19.335 5.73 5.426 12.562 9.136 20.123 11.551 10.912 3.485 21.859 3.633 32.83.559 8.724-2.444 16.35-6.876 22.913-13.181 6.871-6.6 11.846-14.368 14.642-23.454.969-3.149 1.579-6.443 1.993-9.716.423-3.338.719-6.752.505-10.096-.36-5.651-1.332-11.243-3.396-16.569-2.415-6.229-5.677-11.983-10.102-17.004-2.326-2.639-4.86-5.096-7.347-7.589a51383.997 51383.997 0 0 0-49.491-49.556 1288.346 1288.346 0 0 0-14.757-14.538c-6.151-5.955-16.253-6.191-22.686-.545-.973.854-1.731 1.958-2.556 2.974-1.017 1.252-1.169 1.297-2.544.502-2.126-1.229-4.519-1.32-6.83-1.252-6.019.177-10.697 2.873-13.879 8.042-.444.72-.788 1.442-1.907 1.068-3.805-1.271-7.498-.664-11.062.913-4.892 2.163-7.776 6.043-9.129 11.117-.312 1.169-.358 2.41-.56 3.858"
			/>
		</g>
	</svg>;
}
// interface IconMenuProps {

// }

export function IconMenu(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 24 24"
			class={props.classNames || ""}
		>
			<path
				fill="currentColor"
				d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"
			/>
		</svg>
	);
}
export function IconPlay(props: IconProps) {
	return (
		<svg
			class={props.classNames || ""}
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 24 24"
		>
			<path
				fill="currentColor"
				d="M10 16.5v-9l6 4.5M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"
			/>
		</svg>
	);
}

export function LoadingSpinner(props: IconProps) {
	return (
		<svg
			class={`animate-spin ${props.classNames}`}
			xmlns="http://www.w3.org/2000/svg"
			fill="none"
			viewBox="0 0 24 24"
		>
			<circle
				class="opacity-25"
				cx="12"
				cy="12"
				r="10"
				stroke="currentColor"
				stroke-width="4"
			/>
			<path
				class="opacity-75"
				fill="currentColor"
				d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
			/>
		</svg>
	);
}
export function IconChapBack(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="1em"
			height="1em"
			viewBox="0 0 24 24"
			class={`${props.classNames}`}
		>
			<path
				fill="none"
				stroke="currentColor"
				stroke-linecap="round"
				stroke-linejoin="round"
				stroke-width="2"
				d="M20 5v14L8 12zM4 5v14"
			/>
		</svg>
	);
}
export function IconChapNext(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="1em"
			height="1em"
			viewBox="0 0 24 24"
			class={`${props.classNames}`}
		>
			<path
				fill="none"
				stroke="currentColor"
				stroke-linecap="round"
				stroke-linejoin="round"
				stroke-width="2"
				d="M4 5v14l12-7zm16 0v14"
			/>
		</svg>
	);
}
export function SpeedIcon(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="100%"
			height="100%"
			viewBox="0 0 24 24"
			class={`${props.classNames}`}
		>
			<path
				fill="currentColor"
				d="m20.38 8.57l-1.23 1.85a8 8 0 0 1-.22 7.58H5.07A8 8 0 0 1 15.58 6.85l1.85-1.23A10 10 0 0 0 3.35 19a2 2 0 0 0 1.72 1h13.85a2 2 0 0 0 1.74-1a10 10 0 0 0-.27-10.44z"
			/>
			<path
				fill="currentColor"
				d="M10.59 15.41a2 2 0 0 0 2.83 0l5.66-8.49l-8.49 5.66a2 2 0 0 0 0 2.83z"
			/>
		</svg>
	);
}
export function IconMoon(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="32"
			height="32"
			viewBox="0 0 24 24"
			class={props.classNames || ""}
		>
			<path
				fill="currentColor"
				d="M12 21q-3.75 0-6.375-2.625T3 12q0-3.75 2.625-6.375T12 3q.35 0 .688.025t.662.075q-1.025.725-1.638 1.888T11.1 7.5q0 2.25 1.575 3.825T16.5 12.9q1.375 0 2.525-.613T20.9 10.65q.05.325.075.662T21 12q0 3.75-2.625 6.375T12 21Z"
			/>
		</svg>
	);
}
export function IconSun(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="32"
			height="32"
			viewBox="0 0 24 24"
			class={props.classNames || ""}
		>
			<path
				fill="currentColor"
				d="M12 5q-.425 0-.713-.288T11 4V2q0-.425.288-.713T12 1q.425 0 .713.288T13 2v2q0 .425-.288.713T12 5Zm4.95 2.05q-.275-.275-.275-.687t.275-.713l1.4-1.425q.3-.3.712-.3t.713.3q.275.275.275.7t-.275.7L18.35 7.05q-.275.275-.7.275t-.7-.275ZM20 13q-.425 0-.713-.288T19 12q0-.425.288-.713T20 11h2q.425 0 .713.288T23 12q0 .425-.288.713T22 13h-2Zm-8 10q-.425 0-.713-.288T11 22v-2q0-.425.288-.713T12 19q.425 0 .713.288T13 20v2q0 .425-.288.713T12 23ZM5.65 7.05l-1.425-1.4q-.3-.3-.3-.725t.3-.7q.275-.275.7-.275t.7.275L7.05 5.65q.275.275.275.7t-.275.7q-.3.275-.7.275t-.7-.275Zm12.7 12.725l-1.4-1.425q-.275-.3-.275-.713t.275-.687q.275-.275.688-.275t.712.275l1.425 1.4q.3.275.288.7t-.288.725q-.3.3-.725.3t-.7-.3ZM2 13q-.425 0-.713-.288T1 12q0-.425.288-.713T2 11h2q.425 0 .713.288T5 12q0 .425-.288.713T4 13H2Zm2.225 6.775q-.275-.275-.275-.7t.275-.7L5.65 16.95q.275-.275.687-.275t.713.275q.3.3.3.713t-.3.712l-1.4 1.4q-.3.3-.725.3t-.7-.3ZM12 18q-2.5 0-4.25-1.75T6 12q0-2.5 1.75-4.25T12 6q2.5 0 4.25 1.75T18 12q0 2.5-1.75 4.25T12 18Z"
			/>
		</svg>
	);
}
export function IconDownload(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="32"
			height="32"
			viewBox="0 0 24 24"
			class={props.classNames || ""}
		>
			<path
				fill="currentColor"
				d="M7 17h10v-2H7v2Zm5-3l4-4l-1.4-1.4l-1.6 1.55V6h-2v4.15L9.4 8.6L8 10l4 4Zm0 8q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22Zm0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20Zm0-8Z"
			/>
		</svg>
	);
}
export function IconSavedLocally(props: IconProps) {
	return (
		<svg
			class={props.classNames || ""}
			xmlns="http://www.w3.org/2000/svg"
			width="32"
			height="32"
			viewBox="0 0 24 24"
		>
			<path
				fill="currentColor"
				d="M10.925 14.05L16.6 8.4l-1.425-1.425l-4.25 4.25L8.8 9.1l-1.4 1.4l3.525 3.55ZM1 21v-2h22v2H1Zm3-3q-.825 0-1.413-.588T2 16V5q0-.825.588-1.413T4 3h16q.825 0 1.413.588T22 5v11q0 .825-.588 1.413T20 18H4Z"
			/>
		</svg>
	);
}

export function IconMaterialSymbolsChevronLeft(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="1em"
			height="1em"
			viewBox="0 0 24 24"
			{...props}
		>
			<path
				fill="currentColor"
				d="m14 18l-6-6l6-6l1.4 1.4l-4.6 4.6l4.6 4.6L14 18Z"
			/>
		</svg>
	);
}

export function IconMaterialSymbolsChevronRight(props: IconProps) {
	return (
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="1em"
			height="1em"
			viewBox="0 0 24 24"
			{...props}
		>
			<path
				fill="currentColor"
				d="M9.4 18L8 16.6l4.6-4.6L8 7.4L9.4 6l6 6l-6 6Z"
			/>
		</svg>
	);
}

export function IconMajesticonsCloseLine(props: IconProps) {
	return (
		<svg
			class={props.classNames || ""}
			xmlns="http://www.w3.org/2000/svg"
			width="1em"
			height="1em"
			viewBox="0 0 24 24"
			{...props}
		>
			<path
				fill="none"
				stroke="currentColor"
				stroke-linecap="round"
				stroke-linejoin="round"
				stroke-width="2"
				d="M12 12L7 7m5 5l5 5m-5-5l5-5m-5 5l-5 5"
			/>
		</svg>
	);
}
</file>

<file path="src/pages/license.astro">
---
import Layout from "@layouts/Layout.astro";
import {getPreferredLangFromHeader} from "@lib/utils";
import config from "src/domainConfig.ts";
const allLicense = await Astro.glob("../licenses/*.md");
let originToMatch = import.meta.env.PROD ? Astro.url.origin : "benin";
if (originToMatch.includes("dot-web.pages.dev")) {
  originToMatch = "benin";
}
const configKey = Object.keys(config).find((key) =>
  originToMatch.toLowerCase().includes(key.toLowerCase())
);
if (!configKey) return Astro.redirect("404");
const configEntry = config[configKey];
if (!configEntry || !configEntry.license) return Astro.redirect("404");
const applicable = allLicense.find((l) =>
  l.file.toLowerCase().includes(configEntry.license.toLowerCase())
);
const preferredLocale = getPreferredLangFromHeader(Astro.request);
const initialDictModule = await import(`../i18n/${preferredLocale}.ts`);
const initialDict = initialDictModule.default;
let Content = applicable ? applicable.Content : "couldn't find that";
---

<Layout
  title="license"
  initialDict={initialDict}
  preferredLocale={preferredLocale}
>
  <div class="max-w-prose mx-auto p-4 licenseContainer text-xl leading-loose">
    <Content />
  </div>
</Layout>
</file>

<file path=".gitignore">
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production

# macOS-specific files
.DS_Store
ignore-notes.md
.dev.vars
stats.html
/functions/\[\[path\]\].js
will-notes.md
.wrangler

# Playwright
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/
/playwright/.auth/
</file>

<file path="playwright.config.ts">
import {defineConfig, devices} from "@playwright/test";

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
// import dotenv from 'dotenv';
// import path from 'path';
// dotenv.config({ path: path.resolve(__dirname, '.env') });

/**
 * See https://playwright.dev/docs/test-configuration.
 */
// todo, error in CI on policy keyl. Let's just add as secret in github
export default defineConfig({
  testDir: "./tests",
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: "list",
  /* Global setup file for API mocking */
  globalSetup: "./tests/setup.ts",
  /* Shared settings for all projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('')`. */
    baseURL: "http://localhost:4321",

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: "on-first-retry",
  },

  /* Run your local dev server before starting the tests */
  webServer: {
    command: "pnpm dev",
    url: "http://localhost:4321",
    reuseExistingServer: !process.env.CI,
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: "chromium-desktop",
      use: {...devices["Desktop Chrome"]},
    },

    /* Test against mobile viewports. */
    {
      name: "mobile-chrome",
      use: {...devices["Pixel 5"]},
    },
  ],

  /* Run your local dev server before starting the tests */
  // webServer: {
  //   command: 'npm run start',
  //   url: 'http://localhost:3000',
  //   reuseExistingServer: !process.env.CI,
  // },
});
</file>

<file path="src/components/PlayerNavigation/ChaptersList.tsx">
import type {IVidWithCustom} from "@customTypes/types";
import {type Accessor, For, Show} from "solid-js";
import {ChapterButton} from "./ChapterButton";
import {currentBook} from "@lib/store";

interface IChapterList {
  chapterButtonOnClick: (arg: IVidWithCustom) => void;
  currentVid: IVidWithCustom;
  showChapSliderButtons: Accessor<boolean>;
}
export function ChapterList(props: IChapterList) {
  return (
    <Show when={props.currentVid}>
      <ul
        data-testid="chapter-list-container"
        data-js="chapterButtonTrack"
        class={`flex flex-nowrap gap-3 items-start content-start px-2 py-4 overflow-x-auto scrollbar-hide  list-none scroll-smooth motion-reduce:scroll-auto w-full`}
      >
        <For each={currentBook()}>
          {(vid) => {
            return (
              <li>
                <ChapterButton
                  currentVid={props.currentVid}
                  vid={vid}
                  onClick={(vid) => props.chapterButtonOnClick(vid)}
                />
              </li>
            );
          }}
        </For>
      </ul>
    </Show>
  );
}
</file>

<file path="src/customTypes/types.ts">
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-interface */
import type {Video, VideoSources} from "./Api";

declare global {
  interface Window {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    dataLayer: Record<string, any>;
  }
}
export interface IVidWithCustom extends Video {
  book: string | undefined;
  originalIdx?: number | null;
  slugName?: string | null;
  chapter?: string | null;
  localizedBookName: string | undefined;
  custom_fields: Video["custom_fields"] & {
    book?: string;
    chapter?: string;
    country?: string;
    language?: string;
    localized_book_name?: string;
  };
  sources: customVideoSources[];
  chapterMarkers: chapterMarkers;
}
export interface customVideoSources extends VideoSources {
  src: string;
  name?: string;
  refId?: string;
}

export type chapterMarkers = {
  chapterStart: number;
  chapterEnd: number;
  label: string;
  xPos: string;
  startVerse: string | null;
  endVerse: string | null;
}[];
export type AnyFunction<Args extends never[], Return> = (
  ...args: Args
) => Return;
export type AnyAsyncFunction<Args extends never[], Return> = (
  ...args: Args
) => Promise<Return>;

export interface CookieOptions {
  expires?: number | Date;
  path?: string;
  domain?: string;
  secure?: boolean;
  sameSite?: "strict" | "lax" | "none";
}
export interface userPreferencesI {
  preferUsingSavedVideoIfAvailable?: boolean;
  prefersDark?: boolean;
  playbackSpeed?: string;
}
export interface IDownloadPreferences {
  saveToServiceWorker: boolean;
  downloadOffline: boolean;
  justThisVideo: boolean;
  swPayload: object | null | undefined;
}
export type wholeBookPresets = "BIG" | "SMALL";
export type IpopulateSwPayload =
  | {
      type: "VID";
      val: string;
    }
  | {
      type: "BOOK";
      val: wholeBookPresets;
    };

export type i18nDictWithLangCode = Record<string, i18nDict>;

export type i18nDict = Record<string, string>;

export interface cloudflareEnv {
  ACCOUNT_ID: string;
  PLAYER_ID: string;
  POLICY_KEY: string;
}
export interface envPropsForPlayer {
  accountId: string;
  playerId: string;
}
</file>

<file path="src/global.css">
:root,
:root.light {
  --clrSurface: 90 3% 12%; /* hsl(90,3%,12%) */
  --clrBase: 72 46% 98%; /* hsl(72, 46%, 98%) */
  --clrPrimary: 20 100% 56%; /* hsl(20, 100%, 56%) */
  --clrSecondary: 75 89% 56%; /* hsl(75, 89%, 56%) */
  --clrTertiary: 240 96% 68%; /* hsl(240, 96%, 68%) */
}

:root.dark {
  --clrSurface: 72 46% 98%; /* hsl(72, 46%, 98%) */
  --clrBase: 90 3% 12%; /* hsl(90,3%,12%) */
  --clrPrimary: 20 100% 56%; /* hsl(20, 100%, 56%) */
  --clrSecondary: 75 89% 56%; /* hsl(75 89% 56%) */
  --clrTertiary: 240 96% 68%; /* hsl(240 96%, 68%) */
}

/* SELF HOSTED FONTS */

@font-face {
  font-family: "Montserrat";
  src: local("Montserrat Regular"), local("Montserrat-Regular"),
    url("/fonts/montserrat/Montserrat-Regular.woff2") format("woff2"),
    url("/fonts/montserrat/Montserrat-Regular.woff") format("woff");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Montserrat";
  src: local("Montserrat Bold"), local("Montserrat-Bold"),
    url("/fonts/montserrat/Montserrat-Bold.woff2") format("woff2"),
    url("/fonts/montserrat/Montserrat-Bold.woff") format("woff");
  font-weight: bold;
  font-style: normal;
  font-display: swap;
}

/* =============== VIDEO JS STUFF  ============= */
/********** Range Input Styles **********/
/*Range Reset*/
input[type="range"] {
  -webkit-appearance: none;
  @apply appearance-none bg-transparent cursor-pointer w-40;
}

/* Removes default focus */
input[type="range"]:focus {
  @apply outline-none;
}

/***** Chrome, Safari, Opera and Edge Chromium styles *****/
/* slider track */
input[type="range"]::-webkit-slider-runnable-track {
  -webkit-appearance: none; /* Override default look */
  @apply bg-primary/20 rounded-md h-2;
}

/* slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  @apply mt--2 h-6 w-6 rounded-full bg-primary/80
  /* margin-top: -12px; Centers thumb on the track */;
}

input[type="range"]:focus::-webkit-slider-thumb {
  @apply border border-gray-500 outline outline-3 outline-gray-500 outline-offset-2;
}

/******** Firefox styles ********/
/* slider track */
input[type="range"]::-moz-range-track {
  @apply bg-primary/20 rounded-md h-2;
}

/* slider thumb */
input[type="range"]::-moz-range-thumb {
  @apply mt--2 h-6 w-6 rounded-full bg-primary/80;
}

input[type="range"]:focus::-moz-range-thumb {
  @apply border border-gray-500 outline outline-3 outline-gray-500 outline-offset-2;
}
/********** Range Input Styles **********/
/*Range Reset*/

.video-js {
  width: 100% !important;
  height: 100% !important;
  padding-top: 0 !important;
}
.video-js video,
.video-js img {
  object-fit: cover;
}
.vjs-big-play-button {
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -50%) !important;
  border-radius: 9999px !important;
  height: 6rem !important;
  width: 6rem !important;
  display: inline-grid !important;
  place-content: center !important;
  padding: 0 !important;
  line-height: 2 !important;
  border: none !important;
  background: #f3f3f3 !important;
  color: #9c9c9c !important;
}
.vjs-big-play-button:hover {
  background: hsl(20, 100%, 56%) !important;
}
.vjs-has-started .vjs-big-play-button {
  display: none !important;
}
.vjs-progress-control.vjs-control {
  width: 100%;
  position: absolute;
  top: -100%;
}
.vjs-playback-rate {
  display: inline-block !important;
}
.vjs-big-play-button:hover .vjs-icon-placeholder:before {
  color: white !important;
}
.video-js .vjs-big-play-button .vjs-icon-placeholder:before {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-size: 4rem;
}
.vjs-progress-control .vjs-mouse-display {
  /* left: 85px !important; */
  top: -3.25rem !important;
  align-items: center !important;
  justify-content: center !important;
  flex-direction: column-reverse !important;
  font-size: 0.8em !important;
  background-color: rgba(0, 0, 0, 0.8) !important;
  height: max-content !important;
  width: max-content !important;
  transform: translateX(-50%);
  padding: 0.25rem;
}
.vjs-progress-control .vjs-mouse-display * {
  background: none;
}
.vjs-mouse-display .vjs-time-tooltip {
  float: none !important;
  position: static !important;
  font-size: 1em !important;
  padding: 0;
}
.video-js .vjs-progress-control:hover .vjs-mouse-display {
  display: flex !important;
}
.vjs-progress-control:hover .chapLabelTextHolder,
.vjs-progress-control:focus .chapLabelTextHolder {
  display: inline-block;
}
.vjs-chapters-button {
  display: none !important;
}
.vjs-text-track-cue b {
  font-size: 0.65em;
  display: inline-block;
  transform: translateY(-8px);
}
/* =============== MISC  ============= */
/* gradients some things just are simpler outside of utility css, but it's nice to still have easy media queries that line up with uno breakpoitns */
.y-scroll-gradient {
  background-image: linear-gradient(
    0deg,
    hsl(20, 100%, 56%) 0%,
    hsla(20, 100%, 56%, 0) 55%,
    hsla(20, 100%, 56%, 0) 75%,
    hsla(20, 100%, 56%, 1) 100%
  );
}
.dark .y-scroll-gradient {
  background-image: linear-gradient(
    0deg,
    hsla(90, 3%, 11%, 1) 0%,
    hsla(90, 3%, 12%, 0) 55%,
    hsla(90, 3%, 12%, 0) 75%,
    hsla(90, 3%, 11%, 1) 100%
  );
}

@screen sm {
  .x-scroll-gradient {
    background: rgb(0, 0, 0);
    background: linear-gradient(
      90deg,
      rgba(0, 0, 0, 0.1) 1%,
      rgba(0, 0, 0, 0) 2%,
      rgba(0, 0, 0, 0) 97%,
      rgba(0, 0, 0, 0.1) 100%
    );
  }
}
/* #6eb9f7 */
/* #47a7f5 */
.seekRipple {
  overflow: hidden;
  background: hsla(0, 100%, 100%, 0.3);
}
.seekRipple:after {
  content: "";
  background: hsla(0, 100%, 100%, 0.2);
  /* background: hsla(0, 0%, 0%, .1); */
  position: absolute;
  top: 50%;
  height: 1rem;
  width: 1rem;
  transform: translateY(-50%);
  border-radius: 9999px;
  animation: ripple-animation 0.2s infinite alternate;
}
#seekRippleForward:after {
  left: 50%;
  /* border-radius: 100% 0% 0% 100% / 50% 50% 50% 50% ; */
}
#seekRippleBackward:after {
  right: 50%;
  /* border-radius: 0% 100% 100% 0% / 50% 50% 50% 50% ; */
}
@keyframes ripple-animation {
  0% {
    transform: translateY(-50%) scale(0.1);
  }
  100% {
    transform: translateY(-50%) scale(50);
  }
}

.licenseContainer h1 {
  font-size: 3rem;
}
.licenseContainer a {
  color: hsl(var(--clrPrimary));
  text-decoration: underline;
}
</file>

<file path="tsconfig.json">
{
  "extends": "astro/tsconfigs/strict",
  "exclude": ["dist", "public", "./functions"],
  "compilerOptions": {
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "baseUrl": ".",
    "allowImportingTsExtensions": true,
    "lib": ["ESNext", "DOM", "WebWorker"],
    "types": [
      "astro/client",
      "@cloudflare/workers-types",
      "vite-plugin-pwa/client",
      "vite-plugin-pwa/info",
      "@types/video.js"
    ],

    "paths": {
      "@layouts/*": ["src/layouts/*"],
      "@components/*": ["src/components/*"],
      "@lib/*": ["src/lib/*"],
      "@customTypes/*": ["src/customTypes/*"],
      "@utils": ["src/lib/utils.ts"],
      "@i18n/*": ["src/i18n/*"],
      "@src/*": ["src/*"]
    }
  }
}
</file>

<file path="src/lib/routes.ts">
import type {PlaylistResponse} from "@customTypes/Api";
import type {IVidWithCustom, envPropsForPlayer} from "@customTypes/types";
import {
  groupObjectsByKey,
  getUserPreferences,
  getPreferredLangFromHeader,
  mutateSortVidsArray,
} from "@utils";
import config from "@src/domainConfig.ts";

export const DOWNLOAD_SERVICE_WORK_URL = "download-video";

export async function getPlaylistData(origin: string, playlist: string) {
  try {
    const urlToFetch = `${origin}/api/getPlaylist?playlist=${playlist}`;
    const response = await fetch(urlToFetch);
    if (response.ok) {
      const data = response.json() as PlaylistResponse;
      return data;
    }
  } catch (error) {
    console.error(error);
    return;
  }
}

export async function getPageData(Astro: any, origin?: string) {
  // FIGURE OUT WHICH PLAYLIST TO LOAD BASED ON DOMAIN
  let originToMatch = import.meta.env.PROD ? Astro.url.origin : (origin || "drcswahili");
  if (
    originToMatch.includes(".pages.dev") ||
    originToMatch.includes("127.0.0.1") ||
    originToMatch.includes("localhost")
  ) {
    originToMatch = "drcswahili";
  }

  let matchingKey = Object.keys(config).find((key) =>
    originToMatch.toLowerCase().includes(key.toLowerCase())
  );
  if (!matchingKey || !config[matchingKey]) return null;
  const configObj = config[matchingKey];
  const playlist = configObj.playlist;
  const playlistDisplayName = configObj.displayName;
  if (!playlist) return null;

  // Setup i18n
  const preferredLocale = getPreferredLangFromHeader(Astro.request);
  const initialDictModule = await import(`../i18n/${preferredLocale}.ts`);
  const initialDict = initialDictModule.default;
  let videojsInitalDict;
  try {
    let module = await import(
      `../../node_modules/video.js/dist/lang/${preferredLocale}.json`
    );
    videojsInitalDict = module.default as Record<string, string>;
  } catch (error) {
    console.error({error});
  }

  // DATA FETCHING
  let userPreferences = getUserPreferences(Astro);
  let data = await getPlaylistData(Astro.url.origin, playlist);
  if (!data) return null;

  // DATA SHAPING
  // type coercion here to add a few extra types below on this vids array.
  const vids = data.videos as IVidWithCustom[];
  if (!vids || !vids.length) {
    return null;
  }
  const {sortedVids, filteredByMatchingReferenceId} = mutateSortVidsArray(vids);
  const bucketized = groupObjectsByKey<IVidWithCustom, "book">(
    sortedVids,
    "book"
  );
  if (filteredByMatchingReferenceId.notMatching?.length) {
    bucketized.other = filteredByMatchingReferenceId.notMatching;
  }

  // CLOUDFLARE ENV SETUP
  let cfEnv: envPropsForPlayer = {
    accountId: "",
    playerId: "",
  };
  if (import.meta.env.DEV) {
    (cfEnv.accountId = import.meta.env.ACCOUNT_ID),
      (cfEnv.playerId = import.meta.env.PLAYER_ID);
  } else {
    const runtime = Astro.locals.runtime;
    cfEnv.accountId = runtime.env.ACCOUNT_ID;
    cfEnv.playerId = runtime.env.PLAYER_ID;
  }
  if (!cfEnv.accountId || !cfEnv.playerId) {
    return null;
  }

  return {
    playlist,
    playlistDisplayName,
    preferredLocale,
    initialDict,
    videojsInitalDict,
    userPreferences,
    bucketized,
    cfEnv
  };
}
</file>

<file path="astro.config.mjs">
import cloudflare from "@astrojs/cloudflare";
import solidJs from "@astrojs/solid-js";
import AstroPWA from "@vite-pwa/astro";
import {defineConfig} from "astro/config";
import {visualizer} from "rollup-plugin-visualizer";
import UnoCSS from "unocss/astro";

const isDev = import.meta.env.DEV;
// https://astro.build/config
export default defineConfig({
  integrations: [
    UnoCSS(),
    solidJs(),
    AstroPWA({
      workbox: {
        disableDevLogs: false,
      },
      srcDir: "src",
      filename: "sw.ts",
      strategies: "injectManifest",
      registerType: "autoUpdate",
      // manifest: {},
      devOptions: {
        enabled: true,
        type: "module",
        /* other options */
      },
      injectManifest: {
        globIgnores: ["**/_worker.js/**"],
      },
    }),
  ],
  output: "server",
  adapter: cloudflare({
    platformProxy: {
      enabled: true,
      configPath: ".dev.vars",
    },
  }),
  vite: {
    // build: {
    //   minify: false,
    // },
    // ssr: {
    //   noExternal: ["@kobalte/core", "@internationalized/message"],
    // },
    plugins: [
      visualizer({
        // goal:  ~100kib of HTML/CSS/Fonts (e.g. check network tab for amount loaded), and then ~300-350kib JS gzipped:
        gzipSize: true,
      }),
    ],
  },
});
</file>

<file path="src/components/AppWrapper.tsx">
import type {
  IVidWithCustom,
  envPropsForPlayer,
  userPreferencesI,
} from "@customTypes/types";
import {VidPlayer} from "./Player";

interface IAppWrapperProps {
  locale: string;
  initialDict: Record<string, string>;
  vids: Record<string | number | symbol, IVidWithCustom[]>;
  playlist: string | undefined;
  playlistDisplayName: string | undefined;
  initialData: {
    vids: IVidWithCustom[];
    chap: IVidWithCustom;
    verseRouting: string | undefined;
  };
  userPreferences: userPreferencesI | undefined;
  videojsInitalDict: Record<string, string> | undefined;
  playerEnv: envPropsForPlayer;
}
export function AppWrapper(props: IAppWrapperProps) {
  return (
    <VidPlayer
      initialData={props.initialData}
      playlist={props.playlist}
      playlistDisplayName={props.playlistDisplayName}
      userPreferences={props.userPreferences}
      vids={props.vids}
      videojsInitalDict={props.videojsInitalDict}
      playerEnv={props.playerEnv}
      initialDict={props.initialDict}
    />
  );
}
</file>

<file path="src/lib/utils.ts">
import type {IVidWithCustom, userPreferencesI} from "@customTypes/types";
import type {AstroGlobal} from "astro";
import {getBibleBookSort} from "src/constants";
import {baseLocale, supportedLanguages} from "@i18n/index";

export function formatDuration(milliseconds: number) {
  // Convert milliseconds to seconds
  const seconds = Math.floor(milliseconds / 1000);

  // Calculate hours, minutes, and remaining seconds
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = seconds % 60;

  // Format the time string and trim leading zeros
  let timeString = "";

  if (hours > 0) {
    timeString = `${hours}:${minutes
      .toString()
      .padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }

  if (hours == 0 || minutes > 0) {
    timeString = `${minutes.toString().padStart(2, "0")}:${remainingSeconds
      .toString()
      .padStart(2, "0")}`;
  } else {
    timeString = `0:${remainingSeconds.toString().padStart(2, "0")}`;
  }

  return timeString;
}

export function convertToValidFilename(string: string) {
  return string.replace(/[\/|\\:*?"<>]/g, " ").replace(" ", "_");
}
export function normalizeBookName(bookname: string | undefined) {
  if (!bookname) return "";
  const parts = bookname.split(/(\d+)/).filter((r) => !!r); // Split on any digits
  if (parts.length > 1) {
    const secondPart = upperFirstLowerRest(parts[1]);
    return `${parts[0]} ${secondPart}`;
  } else return upperFirstLowerRest(bookname);
}
export function upperFirstLowerRest(bookName: string) {
  return `${bookName.trim().slice(0, 1).toUpperCase()}${bookName
    .trim()
    .slice(1)
    .toLowerCase()}`;
}

export function convertTimeToSeconds(timeStr: string): number {
  const [mins, secs] = timeStr.split(":").map(Number);
  const milliseconds = Number(timeStr.split(".")[1]);
  return mins * 60 + secs + milliseconds / 1000;
}
export function bytesToMb(bytes: number | undefined) {
  if (!bytes) return "";
  const val = Math.round(bytes / 1000 / 1000);
  return String(val);
}

export function groupObjectsByKey<
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends {[key: string]: any},
  K extends keyof T
>(objects: T[], key: K): Record<T[K], T[]> {
  const groups = {} as Record<T[K], T[]>;

  // Iterate over each object in the array
  objects.forEach((object) => {
    // Get the value of the specified key
    const value = object[key];

    // If there is no group for the value, create one
    if (!groups[value]) {
      groups[value] = [];
    }

    // Add the object to the corresponding group
    groups[value].push(object);
  });
  return groups;
}

export function getUserPreferences(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  AstroObj: AstroGlobal
): userPreferencesI | undefined {
  if (AstroObj.cookies.has("userPreferences")) {
    const cookie = AstroObj.cookies.get("userPreferences")?.json();
    return cookie as userPreferencesI;
  }
}
export function getPreferredLangFromHeader(request: Request) {
  if (!request) return baseLocale;
  const langs = request.headers.get("Accept-Language");
  if (!langs) return baseLocale;
  const langsArr = langs.split(",").map((lang) => {
    const arr = lang.split(";");
    return arr[0];
  });
  let preferredLocale = baseLocale; //default
  for (let i = 0; i < langsArr.length; i++) {
    //   let val = item() as i18nDictSubKeysType
    const langKey = langsArr[i];
    const matchedLocale = supportedLanguages.find(
      (locale) => locale.code === langKey
    );
    if (matchedLocale) {
      preferredLocale = langKey;
      break;
    } else continue;
  }
  return preferredLocale;
}
export function mutateSortVidsArray(vids: IVidWithCustom[]) {
  type accType = {
    matching: IVidWithCustom[];
    notMatching: IVidWithCustom[];
  };
  const filteredByMatchingReferenceId = vids.reduce(
    (accumulator: accType, current) => {
      if (current.custom_fields?.book && current.custom_fields?.chapter) {
        accumulator.matching.push(current);
      } else {
        accumulator.notMatching.push(current);
      }
      return accumulator;
    },
    {
      matching: [],
      notMatching: [],
    }
  );
  const sortedVids = filteredByMatchingReferenceId.matching.sort((a, b) => {
    const aCustomBook = a.custom_fields?.book;
    const bCustomBook = b.custom_fields?.book;
    if (!aCustomBook || !bCustomBook) return 0;
    const aBookSort = getBibleBookSort(aCustomBook);
    const bBookSort = getBibleBookSort(bCustomBook);
    const aChap = Number(a.custom_fields?.chapter);
    const bChap = Number(b.custom_fields?.chapter);
    let retVal;
    if (aBookSort == bBookSort) {
      retVal = aChap < bChap ? -1 : aChap == bChap ? 0 : 1;
    } else {
      retVal = aBookSort < bBookSort ? -1 : aBookSort == bBookSort ? 0 : 1;
    }
    return retVal;
  });

  sortedVids.forEach((vid, idx) => {
    vid.originalIdx = idx;
    vid.slugName = convertToValidFilename(String(vid.name));
    vid.book = vid.custom_fields?.book?.toUpperCase();
    vid.chapter = vid.custom_fields?.chapter;
    vid.localizedBookName =
      vid.custom_fields?.localized_book_name ||
      vid.custom_fields?.book?.toUpperCase();
    // vid.localizedBookName = vid.custom_fields?.lo
  });
  return {sortedVids, filteredByMatchingReferenceId};
}
</file>

<file path="src/components/Header.tsx">
import {
  DotLogo,
  IconMajesticonsCloseLine,
  IconMenu,
  IconMoon,
  IconSun,
} from "@components/Icons";
import {
  mobileHorizontalPadding,
  handleColorSchemeChange,
  setUpThemeListener,
  updateCookiePrefByKey,
} from "@lib/UI";
import {ToggleButton} from "@kobalte/core";
import {Show, createSignal, onMount} from "solid-js";

import type {i18nDict} from "@customTypes/types";
import * as i18n from "@solid-primitives/i18n";

type HeaderProps = {
  prefersDark?: boolean | undefined;
  initialPath: string;
  initialDict: i18nDict;
};
export function Header(props: HeaderProps) {
  // eslint-disable-next-line solid/reactivity
  const [prefersDark, setPrefersDark] = createSignal(!!props.prefersDark);
  const [menuIsOpen, setMenuIsOpen] = createSignal(false);
  const t = i18n.translator(() => props.initialDict);

  onMount(() => {
    const darkModeMediaQuery = setUpThemeListener(setPrefersDark);
    darkModeMediaQuery &&
      darkModeMediaQuery.addEventListener("change", (e) =>
        handleColorSchemeChange(e, setPrefersDark)
      );
  });

  function handleThemeToggle(prefersDark: boolean) {
    const htmlElement = document.querySelector("html") as HTMLHtmlElement;
    setPrefersDark(prefersDark);
    if (!prefersDark) {
      htmlElement.classList.remove("dark");
      htmlElement.classList.add("light");
    } else {
      htmlElement.classList.add("dark");
      htmlElement.classList.remove("light");
    }
    updateCookiePrefByKey("prefersDark", prefersDark);
  }

  return (
    <div class="relative">
      <header
        class={`${mobileHorizontalPadding} py-2 flex justify-between items-center relative`}
      >
        <span data-testid="header-logo" class="w-32 md:w-48">
          <DotLogo />
        </span>
        <div class="flex gap-2">
          <ToggleButton.Root
            data-testid="header-theme-toggle"
            class="toggle-button"
            aria-label="Light Mode or Dark Mode"
            pressed={prefersDark()}
            onChange={(isPressed) =>
              handleThemeToggle(isPressed as unknown as boolean)
            }
          >
            <Show when={prefersDark()} fallback={<IconMoon />}>
              <IconSun />
            </Show>
          </ToggleButton.Root>

          <ToggleButton.Root
            data-testid="header-menu-toggle"
            pressed={menuIsOpen()}
            onChange={() => setMenuIsOpen(!menuIsOpen())}
          >
            <IconMenu classNames="w-8" />
          </ToggleButton.Root>
        </div>
        {/* </span> */}
      </header>
      <Show when={menuIsOpen()}>
        <div
          class="fixed inset-0 bg-black/30 dark:bg-black/50 z-30"
          onClick={() => setMenuIsOpen(false)}
        />
      </Show>
      <div class="relative overflow-hidden w-full">
        <div
          class={`w-full max-w-md  z-40 bg-white absolute right-0 top-0 transform transition-250 translate-x-full p-4 h-full fixed rounded-md dark:bg-[#181817] ${
            menuIsOpen() ? "translate-x-0!" : ""
          }`}
        >
          <button
            data-testid="header-menu-close"
            class="block ml-auto text-4xl hover:(text-primary) focus:(text-primary) transform active:(scale-95)"
            onClick={() => setMenuIsOpen(!menuIsOpen())}
          >
            <IconMajesticonsCloseLine />
          </button>
          <div class="flex flex-col divide-y border-gray-600 dark:border-gray-300 mt-12">
            <Show when={props.initialPath != "/"}>
              <a
                class="block py-3  text-lg hover:(text-primary underline)"
                href="/"
              >
                {t("homePage")}
              </a>
            </Show>
            <a
              class="block  py-3 text-lg hover:(text-primary underline)"
              href="/license"
            >
              {t("license")}
            </a>
            <a
              class="block  py-3 text-lg hover:(text-primary underline)"
              // todo: change when there are individual about pages. Alos for different environments potentially.
              href="https://slbible.com/"
            >
              {t("about")}
            </a>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/UI.tsx">
import type {
  IVidWithCustom,
  IpopulateSwPayload,
  customVideoSources,
  userPreferencesI,
  wholeBookPresets,
  chapterMarkers,
} from "@customTypes/types";
import type {Setter} from "solid-js";
// typings sort of messed in v8 of the lib. uphttps://github.com/videojs/video.js/issues/8109
import type Player from "video.js/dist/types/player";

import {
  currentBook,
  currentVid,
  setCurrentBook,
  setCurrentChapLabel,
  setCurrentVid,
  setDownloadPreference,
  vidProgress,
  vjsPlayer,
  currentPlaylist,
} from "@lib/store";
import {cleanUpOldChapters} from "@components/Player/ChapterMarker";
import {convertTimeToSeconds, formatDuration} from "./utils";
import {ChapterMarker} from "@components/Player/ChapterMarker";
import {SW_CACHE_NAME} from "src/constants";

export const CONTAINER = "max-w-[1000px] mx-auto";
// @unocss-include
export const mobileHorizontalPadding = "px-3";
export const debounce = <T extends unknown[]>(
  callback: (...args: T) => void,
  wait: number
): ((...args: T) => void | undefined) => {
  let timeoutId: number | null = null;
  return (...args: T) => {
    if (!import.meta.env.SSR) {
      window.clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => {
        callback(...args);
      }, wait);
    }
  };
};

export function getJsonFromDocCookie(key?: string): userPreferencesI | null {
  const keyToUse = key || "userPreferences";
  const cookieVal = document.cookie
    .split(";")
    ?.find((row) => row.replaceAll(" ", "").startsWith(keyToUse))
    ?.split("=")?.[1];
  if (!cookieVal) return null;
  let parsedObj: object | null = null;
  try {
    parsedObj = JSON.parse(cookieVal);
  } catch (error) {
    console.error(error);
  }
  return parsedObj;
}

export function setCookie(value: string, key?: string): void {
  const keyToUse = key || "userPreferences";

  const defaultCookiesOptions = {
    expires: new Date("01-18-2038").toUTCString(),
    path: "/",
    secure: true,
    sameSite: "strict",
  };
  // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies cookie prefxies

  const cookieString =
    `${keyToUse}=${value};` +
    `expires=${defaultCookiesOptions.expires};` +
    defaultCookiesOptions.path +
    +(defaultCookiesOptions.secure ? `secure;` : "") +
    (defaultCookiesOptions.sameSite
      ? `sameSite=${defaultCookiesOptions.sameSite};`
      : "");

  document.cookie = cookieString;
}

interface playerCustomHotKeysParams {
  e: KeyboardEvent;
  vjsPlayer: Player;
  increment: number;
  setJumpingBackAmount: Setter<unknown>;
  setJumpingForwardAmount: Setter<unknown>;
}
export function playerCustomHotKeys({
  e,
  vjsPlayer,
  increment,
  setJumpingBackAmount,
  setJumpingForwardAmount,
}: playerCustomHotKeysParams) {
  const currentTime = vjsPlayer.currentTime();
  let uiJumpingTimeout: number | null = null;
  if (!currentTime) return;
  switch (e.key) {
    case "ArrowLeft":
      vjsPlayer.currentTime(currentTime - increment);
      setJumpingBackAmount(formatDuration((currentTime - increment) * 1000));
      if (uiJumpingTimeout) {
        window.clearTimeout(uiJumpingTimeout);
      }
      uiJumpingTimeout = window.setTimeout(() => {
        setJumpingBackAmount(null);
      }, 250);
      break;
    case "ArrowRight":
      vjsPlayer.currentTime(currentTime + increment);
      setJumpingForwardAmount(formatDuration((currentTime + increment) * 1000));
      if (uiJumpingTimeout) {
        window.clearTimeout(uiJumpingTimeout);
      }
      uiJumpingTimeout = window.setTimeout(() => {
        setJumpingForwardAmount(null);
      }, 250);
      break;
    default:
      break;
  }
}

export function handleColorSchemeChange(
  e: MediaQueryListEvent,
  setPrefersDark: Setter<boolean>
) {
  const htmlElement = document.querySelector("html") as HTMLHtmlElement;
  const currCookie: userPreferencesI = getJsonFromDocCookie() || {};
  if (e.matches) {
    htmlElement.classList.add("dark");
    setPrefersDark(true);
    // write prefersDark True to cookie
    const currCookie: userPreferencesI | null = getJsonFromDocCookie();

    if (currCookie) {
      currCookie.prefersDark = true;
    }
  } else {
    htmlElement.classList.remove("dark");
    setPrefersDark(false);
    const currCookie: userPreferencesI | null = getJsonFromDocCookie();
    if (currCookie) {
      currCookie.prefersDark = false;
    }
    // write prefersDark False to cookie
  }
  // write out cookie on change;
  setCookie(JSON.stringify(currCookie).trim());
}
export function setUpThemeListener(setPrefersDark: Setter<boolean>) {
  if (import.meta.env.SSR) return;
  const darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
  const htmlElement = document.querySelector("html") as HTMLHtmlElement;

  if (
    darkModeMediaQuery.matches &&
    !htmlElement.classList.contains("light") &&
    !htmlElement.classList.contains("dark")
  ) {
    htmlElement.classList.add("dark");
    const currCookie: userPreferencesI = getJsonFromDocCookie() || {};
    currCookie.prefersDark = true;
    setCookie(JSON.stringify(currCookie).trim());
    setPrefersDark(true);
  }
  return darkModeMediaQuery;
}
export function updateCookiePrefByKey<K extends keyof userPreferencesI>(
  key: K,
  val: userPreferencesI[K]
) {
  const currCookie: userPreferencesI = getJsonFromDocCookie() || {};
  currCookie[key] = val;
  setCookie(JSON.stringify(currCookie).trim());
}

export function changeVid(chapNum: string | null | undefined) {
  const cb = currentBook();
  if (!chapNum || !cb) return;
  const newVid = cb.find((vid) => vid.chapter == chapNum);
  if (newVid) {
    setCurrentVid(newVid);
  }
}

export function changePlayerSrc(vid: IVidWithCustom) {
  if (!vjsPlayer()) return;
  vjsPlayer()?.pause();
  changeVid(vid.chapter);
  const httpsOnly = vid.sources.filter((srcObj) =>
    srcObj.src.startsWith("https")
  );
  vid.sources && vjsPlayer()?.src(httpsOnly);
  vid.poster && vjsPlayer()?.poster(vid.poster);
  vjsPlayer()?.load();
  vjsPlayer()?.one("loadedmetadata", () => {
    handleChapters(vid);
  });
}
export async function fetchRemoteChaptersFile(src: string) {
  try {
    const chapterVttRes = await fetch(src);
    const chapterVtt = await chapterVttRes.text();
    return chapterVtt;
  } catch (error) {
    console.error(error);
    return;
  }
}
function distributeChapterMarkers(markers: chapterMarkers) {
  // debugger;
  const plyr = vjsPlayer();
  if (!plyr || import.meta.env.SRR) return;
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore  - controlBar does exist.  Typings are wrong
  const sb = plyr.controlBar?.progressControl?.seekBar?.el();
  markers.forEach((marker) => {
    // debugger;
    let span = document.createElement("span");
    span.dataset.role = "chapterMarker";
    span.classList.add(
      "w-1",
      "h-full",
      "inline-block",
      "bg-primary",
      "absolute"
    );
    span.style.left = `${marker.xPos}%`;
    // const chapMarker = <ChapterMarker leftAmt={marker.xPos} />;
    sb.appendChild(span);
  });
}

export async function getChaptersArrFromVtt(vid: IVidWithCustom) {
  cleanUpOldChapters();
  // debugger;
  const chapterObj = vid.text_tracks?.find((tt) => tt.kind === "chapters");
  if (!chapterObj || !chapterObj.src || !chapterObj.sources) {
    setCurrentVid("chapterMarkers", []);
    return;
  }
  const srcToFetch = chapterObj.sources.find((srcO) =>
    srcO.src?.startsWith("https")
  );
  if (!srcToFetch || !srcToFetch.src) return;
  if (vid.chapterMarkers) return vid.chapterMarkers;
  const plyr = vjsPlayer();
  if (!plyr) return;
  const chapterVtt = await fetchRemoteChaptersFile(srcToFetch.src);
  if (!chapterVtt) {
    setCurrentVid("chapterMarkers", []);
    return;
  }
  const labelRegex = /(?:\d? ?\w+ ?\d*:)(\d+)-(\d+)/;
  /* 
  These should all match: optional digit, optional space, arbitrary num letters, optional space, 1+ number, colon (required), capture all digits after the colon, and be followed by a - and arbitrary digit numbes. 
  2 Pierre 2:1-3
John 2:1-3
2Pierre2:1-3
Luc2:17-28
  */
  const vttChapsArray = chapterVtt
    .split("\n\n")
    .filter((segment) => segment.includes("-->"))
    .map((chapter) => {
      const totalDur = plyr.duration();
      const parts = chapter.split("\n");
      const timeStamp = parts
        .find((line) => line.includes("-->"))!
        .split("-->");
      const startTime = convertTimeToSeconds(timeStamp[0]);
      const endTime = convertTimeToSeconds(timeStamp[1]);
      const labelMatches = parts
        .find((p) => labelRegex.test(p))!
        .match(labelRegex);
      const xPos = String((startTime / totalDur!) * 100);
      return {
        chapterStart: startTime,
        chapterEnd: endTime,
        label: parts[1],
        startVerse: labelMatches ? labelMatches[1] : null,
        endVerse: labelMatches ? labelMatches[2] : null,
        xPos: xPos,
      };
    });

  setCurrentVid("chapterMarkers", vttChapsArray);
  // debugger;
  return vttChapsArray;
}
export async function handleChapters(vid: IVidWithCustom) {
  const chapters = await getChaptersArrFromVtt(vid);
  if (!chapters) return;
  distributeChapterMarkers(chapters);
}
export async function handleVerseProvidedInRouting(
  vid: IVidWithCustom,
  routingVerse: string
) {
  const numRouting = Number(routingVerse);
  if (!numRouting) return;
  const chapters = await getChaptersArrFromVtt(vid);
  if (!chapters || !chapters.length) return;
  const applicableChapter = chapters.find((chapter) => {
    return (
      Number(chapter.startVerse) <= numRouting &&
      Number(chapter.endVerse) >= numRouting
    );
  });
  return applicableChapter ? applicableChapter : null;
}

export function getChapterText(timeInSeconds: number) {
  const cVid = currentVid;
  if (!cVid || !cVid.chapterMarkers) return;
  const currentChap = cVid.chapterMarkers.find((marker) => {
    return (
      timeInSeconds >= marker.chapterStart && timeInSeconds < marker.chapterEnd
    );
  });
  if (!currentChap) return;
  return currentChap.label;
}

export function trackAdjacentChap() {
  // A hack to make this function a tracker of progress. do not delete.  Ideally the progress would be updated as a store signal, but the BC player has its own events that are pushed as a store.
  // eslint-disable-next-line
  const progress = vidProgress();
  const next = getAdjacentChap("NEXT");
  const prev = getAdjacentChap("PREV");
  return {next, prev};
}

export function getAdjacentChap(dir: "NEXT" | "PREV") {
  const player = vjsPlayer();
  const currVid = currentVid;
  if (!player || !currVid) return;
  const currentTime = player.currentTime();
  if (currentTime !== 0 && !currentTime) return;

  if (dir == "NEXT") {
    const nextStart = currVid.chapterMarkers?.find(
      (marker) => marker.chapterStart > currentTime
    );
    return nextStart || undefined;
  } else if (dir == "PREV") {
    const candidates = currVid.chapterMarkers?.filter((marker) => {
      return marker.chapterStart + 3 < currentTime;
    });
    if (!candidates || !candidates.length) return undefined;
    const prevStart = candidates.reduce((acc, current) => {
      return acc.chapterEnd > current.chapterEnd ? acc : current;
    });
    return prevStart || undefined;
  }
}
export function jumpToNextChap(dir: "NEXT" | "PREV") {
  if (dir == "NEXT") {
    const nextStart = getAdjacentChap("NEXT");
    if (nextStart) {
      vjsPlayer()?.currentTime(nextStart.chapterStart);
    }
  } else if (dir == "PREV") {
    const prevStart = getAdjacentChap("PREV");
    if (prevStart) {
      vjsPlayer()?.currentTime(prevStart.chapterStart);
    }
  }
}
export function setNewBook(vids: IVidWithCustom[]) {
  setCurrentBook(vids);
  const firstBook = vids[0];
  setCurrentVid(firstBook);
  changePlayerSrc(firstBook);
}
export const getAllMp4sForBook = (preset: wholeBookPresets) => {
  const currBook = currentBook();
  if (!currBook) return;

  // {name:"higher quality", [srcs]}
  const mp4SrcObjects = currBook.reduce((acc: customVideoSources[], curr) => {
    const mp4s = curr.sources?.filter(
      (src) => src.container === "MP4" && src.src.includes("https")
    );
    let srcToUse = mp4s[0];
    if (preset === "BIG") {
      srcToUse = mp4s.reduce((maxObject, currentObject) => {
        if (!maxObject.size) return currentObject;
        if (!currentObject.size) return maxObject;
        if (!maxObject) {
          maxObject = currentObject;
          return maxObject;
        }
        if (currentObject.size > maxObject.size) {
          return currentObject;
        } else {
          return maxObject;
        }
      });
    } else if (preset === "SMALL") {
      srcToUse = mp4s.reduce((minObject, currentObject) => {
        if (!minObject.size) return currentObject;
        if (!currentObject.size) return minObject;
        if (!minObject) {
          minObject = currentObject;
          return minObject;
        }
        if (currentObject.size < minObject.size) {
          return currentObject;
        } else {
          return minObject;
        }
      });
    }
    if (!srcToUse) return acc;
    srcToUse.name = `${curr.book}-${curr.chapter}`;
    srcToUse.refId = String(curr.reference_id);
    acc.push(srcToUse);
    return acc;
  }, []);

  if (!mp4SrcObjects || !mp4SrcObjects.length) return;
  return mp4SrcObjects;
};

export const wholeBooksOptionsForSelect = () => {
  const currBook = currentBook();
  if (!currBook) return;
  const largestSizes = currBook.map((obj) =>
    Math.max(...obj.sources.map((src) => (src.size ? src.size : 0)))
  );
  const smallestSizes = currBook.map((obj) =>
    Math.min(
      ...obj.sources
        .filter((src) => !!src.size)
        .map((src) => (src.size ? src.size : Infinity))
    )
  );
  const totalSizeOfLargest = largestSizes.reduce((sum, size) => sum + size, 0);
  const totalSizeOfSmallest = smallestSizes.reduce(
    (sum, size) => sum + size,
    0
  );

  const result: {
    size: string;
    totalSize: number;
    wholeBooksOptionsForSelectId: wholeBookPresets;
  }[] = [
    {
      size: "biggest",
      totalSize: totalSizeOfLargest,
      wholeBooksOptionsForSelectId: "BIG",
    },
    {
      size: "smallest",
      totalSize: totalSizeOfSmallest,
      wholeBooksOptionsForSelectId: "SMALL",
    },
  ];
  return result;
};

export const currentMp4Sources = () => {
  const currVid = currentVid;
  if (!currVid) return;
  const mp4Srces = currVid.sources?.filter(
    (source) => source.container === "MP4" && source.src?.includes("https")
  );

  const dedupedSizeChecker: number[] = [];
  const dedupedMp4s = mp4Srces.filter((src) => {
    if (!src.size) return false;
    if (dedupedSizeChecker.includes(src.size)) {
      return false;
    } else {
      src.size && dedupedSizeChecker.push(src.size);
      return true;
    }
  });

  dedupedMp4s.forEach((mp4) => {
    setCurrentVid("sources", (srcArr) => srcArr.src === mp4.src, {
      name: `${currVid.book}-${currVid.chapter}`,
      refId: String(currVid.reference_id),
    });
  });
  return dedupedMp4s;
};

export function populateSwPayload({type, val}: IpopulateSwPayload) {
  if (type === "VID") {
    const currMp4s = currentMp4Sources();
    if (!currMp4s || !currMp4s.length) return;
    const matching = currMp4s.find((source) => String(source.size) === val);
    setDownloadPreference((prev) => {
      return {
        ...prev,
        swPayload: [matching],
      };
    });
  } else if (type === "BOOK") {
    const videoSources = getAllMp4sForBook(val);
    if (!videoSources || !videoSources.length) return;
    setDownloadPreference((prev) => {
      return {
        ...prev,
        swPayload: videoSources,
      };
    });
  }
}

export function handlePopState() {
  if (import.meta.env.SSR) return;
  const currPlaylist = currentPlaylist();
  if (!currPlaylist) return;
  // const currBook = currentBook();
  // if (!currBook) return;

  const bookChap = window.location.pathname.replace("/", "");
  const bookChapParts = bookChap.split(".");
  const currBookSlug = bookChapParts[0];
  if (!currBookSlug) return;
  const thisBook = currPlaylist[currBookSlug.toUpperCase()];
  if (!thisBook) return;
  if (bookChapParts.length >= 2) {
    // book and chap
    const bookSeg = bookChapParts[0];
    const chapSeg = Number(bookChapParts[1]);

    const correspondingVid = thisBook.find(
      (vid) =>
        vid.custom_fields?.book?.toUpperCase() == bookSeg?.toUpperCase() &&
        Number(vid.custom_fields?.chapter) == chapSeg
    );

    if (correspondingVid) {
      setCurrentBook(thisBook);
      changePlayerSrc(correspondingVid);
    }
  }
}
export function handleProgressBarHover(event: Event) {
  const player = vjsPlayer();
  if (!player) return;
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore  - controlBar does exist.  Typings are wrong
  const seekBar = player.controlBar?.progressControl?.seekBar;
  const currentToolTip = document.querySelector(
    ".vjs-progress-control .vjs-mouse-display"
  ) as Element;

  const distance = seekBar.calculateDistance(event);
  const totalDur = player.duration();
  const time = distance * totalDur!;
  const chapLabel = getChapterText(time);
  if (chapLabel && currentToolTip) {
    setCurrentChapLabel(chapLabel);
  } else {
    setCurrentChapLabel("");
  }
}

export function updateHistory(vid: IVidWithCustom, method: "PUSH" | "REPLACE") {
  if (import.meta.env.SSR) return;

  const bookSegment = vid.custom_fields?.book;
  const chapSegment = String(Number(vid.custom_fields?.chapter));
  if (bookSegment && chapSegment) {
    const finUrl = `${location.origin}/${bookSegment}.${chapSegment}`;
    if (window.location.href !== finUrl) {
      const plyr = vjsPlayer();
      plyr && plyr.pause();
      if (method == "PUSH") {
        window.history.pushState(null, "", finUrl);
      } else if (method === "REPLACE") {
        window.history.replaceState(null, "", finUrl);
      }
    }
  }
}
export function handlePlayRateChange(event: Event) {
  const player = vjsPlayer();
  const target = event.target as HTMLInputElement;
  if (!player) return;
  player.playbackRate(Number(target.value));
  const currCookie = getJsonFromDocCookie() || {};
  (currCookie.playbackSpeed = String(target.value)),
    setCookie(JSON.stringify(currCookie));
}
export async function getSavedResponseFromCache(
  vid: IVidWithCustom | undefined
) {
  const falsy = {
    response: null,
    isSaved: false,
  };
  if (import.meta.env.SSR) return falsy;
  if (!vid || !vid.reference_id) return falsy;
  const cache = await caches.open(SW_CACHE_NAME);
  const match = await cache.match(`/${vid.reference_id}`);
  if (!match || (match && match.status != 200)) {
    return falsy;
  } else
    return {
      response: match,
      isSaved: true,
    };
}

export function manageShowingChapterArrows(
  refRect: DOMRect | undefined,
  setterFxn: Setter<boolean>
) {
  if (!refRect) return;
  const chapterBtnTrack = document.querySelector(
    '[data-js="chapterButtonTrack"]'
  ) as HTMLUListElement;
  if (!chapterBtnTrack) return;
  if (chapterBtnTrack.scrollWidth > refRect.width) {
    setterFxn(true);
  } else {
    setterFxn(false);
  }
}

interface IhandleVideoJsTaps {
  el: Element;
  leftDoubleFxn: (number: number) => void;
  rightDoubleFxn: (number: number) => void;
  singleTapFxn: () => void;
  doubleTapUiClue: (dir: "LEFT" | "RIGHT" | null, tapCount: number) => void;
}
export function handleVideoJsTaps({
  el,
  leftDoubleFxn,
  rightDoubleFxn,
  singleTapFxn,
  doubleTapUiClue,
}: IhandleVideoJsTaps) {
  let tapCount = 0;
  let tapTimer: number | undefined;
  let lastTapTimestamp = 0;
  let tapX: number;
  let tapSide: "LEFT" | "RIGHT" | null;

  // Threshold in milliseconds to differentiate between taps and double taps
  const thresholdMilliseconds = 250;
  const singleThresholdMilliseconds = 50;

  function handleTap(event: TouchEvent) {
    const target = event.target as HTMLElement;
    const wasOnVideo = target && target.nodeName === "VIDEO";
    if (event.touches.length === 1 && wasOnVideo) {
      el.classList.add("vjs-user-active");
      lastTapTimestamp = event.timeStamp;
      const tapEvent = event.touches[0];
      const boundingRect = target.getBoundingClientRect();
      tapX = tapEvent.clientX - boundingRect.left;
      const leftThreshold = boundingRect.width * 0.3;
      const rightThreshold = boundingRect.width * 0.7;
      tapCount += 1;
      if (tapX <= leftThreshold) {
        tapSide = "LEFT";
      } else if (tapX >= rightThreshold) {
        tapSide = "RIGHT";
      }
    }
  }
  function handleTouchEnd(event: TouchEvent) {
    const currentTimestamp = event.timeStamp;
    // super fast touches likely doubles.
    if (
      tapCount === 1 &&
      currentTimestamp - lastTapTimestamp < singleThresholdMilliseconds
    ) {
      // single tap too brief -- clear"
      clearTapData();
    } else if (tapCount === 1) {
      // exec single tap
      tapTimer = window.setTimeout(() => {
        // exec single tap then clear
        singleTapFxn();
        clearTapData();
      }, thresholdMilliseconds);
    } else if (tapCount > 1) {
      window.clearTimeout(tapTimer);
      doubleTapUiClue(tapSide, tapCount);
      tapTimer = window.setTimeout(() => {
        if (tapSide === "LEFT") {
          leftDoubleFxn(tapCount);
        } else if (tapSide === "RIGHT") {
          rightDoubleFxn(tapCount);
        }
        // if Tapcount 0: clear all
        // if 1: exec single tap
        // if 2: exec double tap
        clearTapData();
      }, thresholdMilliseconds);
    }
    // otherwise
  }

  // Function to clear tap count and timestamps
  function clearTapData() {
    window.clearTimeout(tapTimer);
    tapCount = 0;
    lastTapTimestamp = 0;
    tapSide = null;
  }

  // target.nodeName="VIDEO"
  //       const tapX = event.tagetTouches[0].clientX - boundingClient.left;
  //
  // if so, e.target.getBoundingClientRect
  // bottom, height, left, right, top, width, x, y
  // Determine if the tap occurred within 30% of the left or right edge of the bounding client
  // const leftThreshold = boundingClientWidth * 0.3;
  // const rightThreshold = boundingClientWidth * 0.7;
  el.addEventListener("touchstart", (e) => handleTap(e as TouchEvent));
  el.addEventListener("touchend", (e) => handleTouchEnd(e as TouchEvent));
  // el.addEventListener("touchcancel", clearTapData);
}
</file>

<file path="src/sw.ts">
import type {customVideoSources} from "@customTypes/types";
import {downloadZip} from "client-zip";
import {CacheableResponsePlugin} from "workbox-cacheable-response";
import {clientsClaim} from "workbox-core";
import {ExpirationPlugin} from "workbox-expiration";
import {cleanupOutdatedCaches, precacheAndRoute} from "workbox-precaching";
import {registerRoute} from "workbox-routing";
import {CacheFirst, StaleWhileRevalidate} from "workbox-strategies";
import {SW_CACHE_NAME} from "./constants";

declare const self: ServiceWorkerGlobalScope;

// Force immediate activation
self.skipWaiting();
clientsClaim();
cleanupOutdatedCaches();

// Explicit listeners to ensure activation happens immediately
self.addEventListener("install", () => void self.skipWaiting());
self.addEventListener("activate", () => void self.clients.claim());

precacheAndRoute(self.__WB_MANIFEST);

// --- ASSET ROUTES ---

registerRoute(
  ({url}) => {
    const isForVidJs =
      url.href.includes("https://players.brightcove.net/6314154063001") ||
      url.href.includes(
        "https://players.brightcove.net/videojs-vtt.js/0.15.4/vtt.global.min.js"
      );

    if (isForVidJs) {
      console.log("vidjs file acknowledged from the service worker!");
    }
    return isForVidJs;
  },
  new StaleWhileRevalidate({
    cacheName: "dot-assets",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200, 304],
      }),
    ],
  })
);

// static assets
registerRoute(
  ({url, sameOrigin, request}) => {
    const isVidJsCss = url.href.includes("video-js.css");
    const astroRegex = /\/_astro\/.+.((css)|(js))/gim;
    const fontsRegex = /fonts\/.+\/.+.woff[2]?/;
    const isAstroHashedContent = astroRegex.test(url.href);
    const isFont = fontsRegex.test(url.href);
    const isImage = sameOrigin && request.destination == "image";
    return isVidJsCss || isAstroHashedContent || isFont || isImage;
  },
  new CacheFirst({
    cacheName: "dot-static-assets",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200, 304],
      }),
    ],
  })
);

// cdn images
registerRoute(
  ({url}) => {
    const vidPosterRegex = /akamaihd.net\/image/;
    const isVidPoster = vidPosterRegex.test(url.href);
    return isVidPoster;
  },
  new CacheFirst({
    cacheName: "dot-cdn-assets",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200, 304],
      }),
      new ExpirationPlugin({
        maxEntries: 1000,
        maxAgeSeconds: 60 * 60 * 24 * 30, //30 days
      }),
    ],
  })
);

// html navigations
registerRoute(
  ({request}) => {
    if (request.mode == "navigate") {
      return true;
    }
  },
  new StaleWhileRevalidate({
    cacheName: "dot-html",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200, 304],
      }),
      new ExpirationPlugin({
        maxEntries: 1000,
        maxAgeSeconds: 60 * 60 * 24 * 30 * 2, //60 days
      }),
    ],
  })
);

// --- DOWNLOAD ROUTE ---

registerRoute(
  ({url, sameOrigin}) => {
    // Matches "download-video" which is set in constants/routes
    const isVidSingleDownload = url.href.includes("download-video");
    return isVidSingleDownload && sameOrigin;
  },
  async ({request}) => {
    const formData = await request.text();
    if (!formData)
      return new Response(null, {
        status: 400,
        statusText: "missing parameters",
      });

    const parameterized = new URLSearchParams(formData);
    const stringPayload = parameterized.get("swPayload");
    if (!stringPayload)
      return new Response(null, {
        status: 400,
        statusText: "missing parameters",
      });

    let payloadData: customVideoSources[];
    const downloadToDevice = parameterized.get("swDownloadDevice") == "true";
    const saveToSw = parameterized.get("swSaveSw") == "true";

    if (!saveToSw && !downloadToDevice) {
      return new Response(null, {
        status: 400,
        statusText: "missing parameters",
      });
    }

    try {
      payloadData = await JSON.parse(stringPayload);
    } catch (error) {
      console.error(error);
      return new Response(null, {
        status: 400,
        statusText: "malformed payload",
      });
    }

    // Helper to save stream to Cache API
    async function sendItToSw(
      name: string,
      stream: ReadableStream<Uint8Array>,
      originalResp: Response
    ) {
      const testCache = await caches.open(SW_CACHE_NAME);
      const res = new Response(stream, {
        headers: {
          "Content-Length": originalResp.headers.get("Content-Length") || "",
          "Content-Type": "video/mp4",
        },
      });
      // Brightcove references are usually numbers/IDs
      await testCache.put(`/${name}`, res);
    }

    // SCENARIO 1: Single File (Direct Stream)
    if (payloadData.length === 1) {
      const srcObj = payloadData[0];
      const fileName = `${srcObj.name}.mp4`;
      const response = await fetch(srcObj.src);

      if (!response.ok) {
        return new Response(null, {status: response.status});
      }

      let bodyToReturn = response.body;
      if (!bodyToReturn) return new Response(null, {status: 500});

      if (saveToSw && srcObj.refId) {
        // Tee the stream: one to cache, one to user
        const [readableDownload, readableSw] = bodyToReturn.tee();
        bodyToReturn = readableDownload;
        // Don't await this, let it run in background
        sendItToSw(srcObj.refId, readableSw, response);
      }

      if (downloadToDevice) {
        return new Response(bodyToReturn, {
          headers: {
            "Content-Type": "application/octet-stream; charset=utf-8",
            "Content-Disposition": `attachment; filename=${fileName}`,
            "Content-Length": response.headers.get("Content-Length") || "",
          },
        });
      } else {
        // Just saving to SW, return success
        return new Response(JSON.stringify({saved: true}), {
          headers: {"Content-Type": "application/json"},
        });
      }
    }

    // SCENARIO 2: Multiple Files (Zip Stream)
    else {
      const totalSize = payloadData.reduce((sum, current) => {
        if (!current.size) return sum;
        sum += current.size;
        return sum;
      }, 0);
      const fileName = `${payloadData[0].name}-playlist`; // Or use book name if available

      async function* lazyFetch() {
        for (const srcObj of payloadData) {
          try {
            const resp = await fetch(srcObj.src);
            const body = resp.body;
            if (!resp.ok || !body) continue;

            if (downloadToDevice && saveToSw) {
              const [readableDownload, readableSw] = body.tee();
              if (srcObj.refId) {
                sendItToSw(srcObj.refId, readableSw, resp);
              }
              yield {
                name: `${srcObj.name}.mp4`,
                input: readableDownload,
                lastModified: new Date(),
              };
            } else if (downloadToDevice) {
              yield {
                name: `${srcObj.name}.mp4`,
                input: body,
                lastModified: new Date(),
              };
            } else if (saveToSw && srcObj.refId) {
              // Just saving, consume the body into cache
              await sendItToSw(srcObj.refId, body, resp);
            }
          } catch (error) {
            console.error(error);
          }
        }
      }

      if (downloadToDevice) {
        const {readable, writable} = new TransformStream();
        // client-zip takes the generator
        const response = downloadZip(lazyFetch());
        response.body?.pipeTo(writable);

        return new Response(readable, {
          headers: {
            "Content-Type": "application/zip",
            "Content-Disposition": `attachment; filename=${fileName}.zip`,
            // Size is approximate or unknown for streamed zip usually, unless calculated
          },
        });
      } else {
        // Execute the generator just to cache files
        const generator = lazyFetch();
        let result = await generator.next();
        while (!result.done) {
          result = await generator.next();
        }
        return new Response(JSON.stringify({saved: true}), {
          headers: {"Content-Type": "application/json"},
        });
      }
    }
  },
  "POST"
);
</file>

<file path="src/domainConfig.ts">
const config: Record<string, Record<string, string>> = {
  benin: {
    playlist: "benin-new-testament",
    license: "benin.md",
    aboutImg: "benin-example",
    displayName: "Benin New Testament",
  },
  ghana: {
    playlist: "ghana-new-testament",
    license: "ghana.md",
    displayName: "Ghana New Testament",
  },
  cote: {
    playlist: "cote-d'ivoire-new-testament",
    license: "cotdivoir.md",
    displayName: "Cote d'Ivoire New Testament",
  },
  togo: {
    playlist: "togo-new-testament",
    license: "togo.md",
    displayName: "Togo New Testament",
  },
  malawi: {
    playlist: "malawi-new-testament",
    license: "malawi.md",
    displayName: "Malawi New Testament",
  },
  cameroon: {
    playlist: "cameroon-new-testament",
    license: "cameroon.md",
    displayName: "Cameroon New Testament",
  },
  tanzania: {
    playlist: "tanzania-new-testament",
    license: "tanzania.md",
    displayName: "Tanzania New Testament",
  },
  drcfrench: {
    playlist: "congo-french-nt",
    license: "congoFrench.md",
    displayName: "Democratic Republic of Congo (French) New Testament",
  },
  drcswahili: {
    playlist: "ase-x-bukavusl",
    license: "bukavu.md",
    displayName: "Democratic Republic of Congo (Swahili) New Testament",
  },
  marathi: {
    playlist: "marathi-nt",
    displayName: "Marathi New Testament",
    license: "marathi.md",
  },
  brazil: {
    playlist: "brazil-nt",
    displayName: "Brazil New Testament",
    license: "brazil.md",
  },
  paraguay: {
    playlist: "pys-nt",
    displayName: "Paraguay New Testament",
    license: "paraguay.md",
  },
  malayalam: {
    playlist: "ins-x-keralasl",
    displayName: "Malayalam New Testament",
    license: "malayalam.md",
  },
} as const;
export default config;
</file>

<file path="src/layouts/Layout.astro">
---
export interface Props {
  title: string;
  initialDict: Record<string, string>;
  preferredLocale: string;
}
import {pwaInfo} from "virtual:pwa-info";
import {Header} from "@components/Header";
const {title} = Astro.props;
import {getUserPreferences} from "@lib/utils";
import "../global.css";
import "@unocss/reset/tailwind.css";
let userPreferences = getUserPreferences(Astro);

// SETUP I18N
const {initialDict} = Astro.props;
const initialPath = Astro.url.pathname;
---

<!doctype html>
<html
  lang="en"
  class={`bg-base ${
    userPreferences?.prefersDark
      ? "dark"
      : userPreferences?.prefersDark === false
        ? "light"
        : ""
  }`}
>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/icons/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/svg+xml"
      sizes="32x32"
      href="/icons/Dot_logo.svg"
    />
    <link rel="manifest" href="/icons/site.webmanifest" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#ff691f" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#202020" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <link href="https://vjs.zencdn.net/8.0.4/video-js.css" rel="stylesheet" />
    <script src="/src/pwa.ts"></script>
    <!-- PWA INFO HERE -->
    {pwaInfo && <Fragment set:html={pwaInfo.webManifest.linkTag} />}
  </head>
  <body class="font-sans leading-relaxed bg-base text-surface pb-[54px]">
    <Header
      client:load
      prefersDark={userPreferences?.prefersDark}
      initialDict={initialDict}
      initialPath={initialPath}
    />

    <slot />
    <!-- Cloudflare Web Analytics -->
    {
      import.meta.env.PROD && (
        <script
          defer
          is:inline
          src="https://static.cloudflareinsights.com/beacon.min.js"
          data-cf-beacon='{"token": "89d66736f5cc483f80819161bfd67ead"}'
        />
      )
    }
    <!-- cloudflare -->
  </body>
</html>

{
  import.meta.env.PROD && (
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-5HN2P1BPRC"
    />
  )
}

<script>
  if (import.meta.env.PROD) {
    // @ts-ignore
    const gtag: Gtag.Gtag = function () {
      window.dataLayer.push(arguments);
    };
    window.dataLayer = window.dataLayer || [];
    gtag("js", new Date());
    gtag("config", "G-5HN2P1BPRC");
  }
</script>
</file>

<file path="package.json">
{
  "name": "dot-vids",
  "type": "module",
  "version": "0.0.1",
  "packageManager": "pnpm@9.3.0",
  "scripts": {
    "dev": "astro dev --host",
    "start": "astro dev",
    "build": "astro build",
    "build-tr": "node --trace-warnings ./node_modules/.bin/astro build",
    "preview": "astro preview",
    "preview-cf": "wrangler pages dev ./dist",
    "cf-dev": "wrangler pages dev --proxy=3000 -- pnpm run dev",
    "astro": "astro",
    "lint": "npx eslint ./",
    "check": "astro check",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:debug": "playwright test --debug",
    "test:e2e:install": "playwright install"
  },
  "dependencies": {
    "@astrojs/cloudflare": "^12.6.2",
    "@astrojs/solid-js": "5.1.0",
    "@brightcove/player-loader": "^1.8.0",
    "@kobalte/core": "^0.13.11",
    "@solid-primitives/i18n": "^2.2.1",
    "@solid-primitives/resize-observer": "^2.1.3",
    "@solid-primitives/scheduled": "^1.5.2",
    "@unocss/reset": "^66.4.1",
    "astro": "^5.12.8",
    "client-zip": "^2.5.0",
    "solid-js": "1.9.7",
    "video.js": "^8.23.3"
  },
  "devDependencies": {
    "@astrojs/check": "^0.9.4",
    "@biomejs/biome": "2.3.11",
    "@cloudflare/workers-types": "^4.20250806.0",
    "@playwright/test": "^1.57.0",
    "@types/node": "^25.0.9",
    "@types/video.js": "^7.3.58",
    "@typescript-eslint/eslint-plugin": "^8.39.0",
    "@typescript-eslint/parser": "^8.39.0",
    "@unocss/transformer-directives": "^66.4.1",
    "@vite-pwa/astro": "^1.1.0",
    "eslint": "^9.32.0",
    "eslint-plugin-astro": "^1.3.1",
    "eslint-plugin-solid": "^0.14.5",
    "msw": "^2.12.7",
    "rollup-plugin-visualizer": "^6.0.3",
    "typescript": "^5.9.2",
    "unocss": "^66.4.1",
    "vite-plugin-pwa": "^1.0.2",
    "workbox-cacheable-response": "^7.3.0",
    "workbox-core": "^7.3.0",
    "workbox-expiration": "^7.3.0",
    "workbox-precaching": "^7.3.0",
    "workbox-routing": "^7.3.0",
    "workbox-strategies": "^7.3.0",
    "workbox-window": "^7.3.0",
    "wrangler": "^4.28.0"
  },
  "resolutions": {
    "intl-messageformat": "10.5.4"
  }
}
</file>

<file path="src/pages/[bookChap]/index.astro">
---
import Layout from "@layouts/Layout.astro";
import {AppWrapper} from "@components/AppWrapper";
import {getPageData} from "@lib/routes";

// Get all shared page data
const pageData = await getPageData(Astro);
if (!pageData) return Astro.redirect("404");

const {
  playlist,
  playlistDisplayName,
  preferredLocale,
  initialDict,
  videojsInitalDict,
  userPreferences,
  bucketized,
  cfEnv
} = pageData;

// BOOK/CHAPTER ROUTING SPECIFIC LOGIC
const {bookChap} = Astro.params;

//Regex = Start with any word or digit, then optional . separator, any number of optional digits (bc we want to match just a book e.g mat if given), and then another set of option digits.  Will match
// Luk, Luk.2, LUK.2.7, 2jn.1, luk27.  Even the last is fine without the period since we'll just treat the two matches as book/chap
const bookChapRegex = /^([\d\w]+)(?:\.)?(\d+)?(?:\.)?(\d+)?/i;
const routingParts = bookChap && bookChap.match(bookChapRegex);
const bookRouting = routingParts && routingParts?.[1]?.toUpperCase();
const chapRouting = routingParts && Number(routingParts?.[2]);
const verseRouting = (routingParts && routingParts?.[3]) || undefined;
const defaultBook =
  bookRouting && bucketized[bookRouting]
    ? bucketized[bookRouting]
    : bucketized[Object.keys(bucketized)[0]];

const defChapIdx = defaultBook.findIndex(
  (chap) => Number(chap.chapter) == Number(chapRouting)
);
const defaultChap = defChapIdx > -1 ? defaultBook[defChapIdx] : defaultBook[0];
const initialData = {vids: defaultBook, chap: defaultChap, verseRouting};

// Cache control headers for book/chapter pages
Astro.response.headers.set(
  "Cache-Control",
  "public, max-age=3600, s-maxage=86400, must-revalidate"
);
---

<Layout
  title={playlist}
  initialDict={initialDict}
  preferredLocale={preferredLocale}
>
  <div class="grid grid-rows-[auto_auto_1fr] overflow-y-auto">
    <AppWrapper
      client:load
      userPreferences={userPreferences}
      initialData={initialData}
      playlist={playlist}
      playlistDisplayName={playlistDisplayName}
      vids={bucketized}
      locale={preferredLocale}
      initialDict={initialDict}
      videojsInitalDict={videojsInitalDict}
      playerEnv={cfEnv}
    />
  </div>
</Layout>
</file>

<file path="src/pages/index.astro">
---
import {AppWrapper} from "@components/AppWrapper";
// home page
import Layout from "@layouts/Layout.astro";
import {getPageData} from "@lib/routes";

// Get all shared page data
const pageData = await getPageData(Astro);
if (!pageData) return Astro.redirect("404");

const {
  playlist,
  playlistDisplayName,
  preferredLocale,
  initialDict,
  videojsInitalDict,
  userPreferences,
  bucketized,
  cfEnv,
} = pageData;

// HOME PAGE SPECIFIC LOGIC
const defaultBook = bucketized[Object.keys(bucketized)[0]];
const defaultChap = defaultBook[0];

const initialData = {
  vids: defaultBook,
  chap: defaultChap,
  verseRouting: undefined,
};
---

<Layout
  title={`DOT ${playlist}`}
  initialDict={initialDict}
  preferredLocale={preferredLocale}
>
  <div class="grid grid-rows-[auto_auto_1fr] overflow-y-auto">
    <AppWrapper
      client:load
      userPreferences={userPreferences}
      initialData={initialData}
      playlist={playlist}
      playlistDisplayName={playlistDisplayName}
      vids={bucketized}
      locale={preferredLocale}
      initialDict={initialDict}
      videojsInitalDict={videojsInitalDict}
      playerEnv={cfEnv}
    />
  </div>
</Layout>
</file>

<file path="src/components/Player.tsx">
import {
	IconChapBack,
	IconChapNext,
	IconDownload,
	IconMaterialSymbolsChevronLeft,
	IconMaterialSymbolsChevronRight,
	LoadingSpinner,
	SpeedIcon,
} from "@components/Icons";
import { SeekBarChapterText } from "@components/Player/SeekBarText";
import { ChapterList } from "@components/PlayerNavigation/ChaptersList";
import type {
	envPropsForPlayer,
	IVidWithCustom,
	i18nDict,
	userPreferencesI,
} from "@customTypes/types";
import { DOWNLOAD_SERVICE_WORK_URL } from "@lib/routes";
import {
	currentChapLabel,
	currentVid,
	playerSpeed,
	setCurrentBook,
	setCurrentPlaylist,
	setCurrentVid,
	setPlayerSpeed,
	setVidProgress,
	setVjsPlayer,
	vjsPlayer,
} from "@lib/store";
import {
	CONTAINER,
	changePlayerSrc,
	currentMp4Sources,
	debounce,
	getAdjacentChap,
	handleChapters,
	handlePlayRateChange,
	handlePopState,
	handleProgressBarHover,
	handleVerseProvidedInRouting,
	handleVideoJsTaps,
	jumpToNextChap,
	manageShowingChapterArrows,
	mobileHorizontalPadding,
	playerCustomHotKeys,
	setNewBook,
	trackAdjacentChap,
	updateHistory,
} from "@lib/UI";
import * as i18n from "@solid-primitives/i18n";
import { createResizeObserver } from "@solid-primitives/resize-observer";
import { throttle } from "@solid-primitives/scheduled";
import { normalizeBookName } from "@utils";
import { createSignal, For, onMount, Show } from "solid-js";
import { PLAYER_LOADER_OPTIONS } from "src/constants";

interface IVidPlayerProps {
	vids: Record<string | number | symbol, IVidWithCustom[]>;
	playlist: string | undefined;
	playlistDisplayName: string | undefined;
	initialData: {
		vids: IVidWithCustom[];
		chap: IVidWithCustom;
		verseRouting: string | undefined;
	};
	videojsInitalDict: Record<string, string> | undefined;
	userPreferences: userPreferencesI | undefined;
	playerEnv: envPropsForPlayer;
	initialDict: i18nDict;
}
export function VidPlayer(props: IVidPlayerProps) {
	// I'm using the store.ts file as a way to pass around state without context.  (e.g. singletons). These setX calls at the top here run on the server once (since calling setX on any store on server is not the same value the client receives during hydration.)
	setCurrentVid(props.initialData.chap);
	setCurrentBook(props.initialData.vids);
	// next two lines disabled due to ssr and setting initial values
	// eslint-disable-next-line solid/reactivity
	setPlayerSpeed(props.userPreferences?.playbackSpeed || "1");
	// eslint-disable-next-line solid/reactivity
	setCurrentPlaylist(props.vids);

	const t = i18n.translator(() => props.initialDict);
	const [showChapSliderButtons, setShowChapSliderButtons] = createSignal(true);
	const [jumpingForwardAmount, setJumpingForwardAmount] = createSignal();
	const [jumpingBackAmount, setJumpingBackAmount] = createSignal();
	const jumpAmount = 5;

	let playerRef: HTMLDivElement | undefined;
	let playerRefContainer: HTMLDivElement | undefined;
	let chaptersContainerRef: HTMLDivElement | undefined;
	const formName = "downloadData";

	//=============== OnMount augments video player  =============
	// This uses the https://github.com/brightcove/player-loader package instead of bare video js for two reasons; One is convenience, but the other is that the analytics for the playlists and player is already set versus having to wire up all the analytics.  It also leaves some of the control that is exposed in the BC Player UI since it's basically configuring the script in BC.  This must be run on mount with a dynamic import since the brightcove player loader uses the window global, which of course, doesn't run in SSR.  Since most of the functionality on the page is related to the player, there is pretty much 0 interactivity until the player loads.
	onMount(async () => {
		const curVid = currentVid;
		// mostly to satisfy ts
		if (!curVid) return;
		// get env vars from bc.

		const { accountId, playerId } = props.playerEnv;
		// eslint-disable-next-line @typescript-eslint/ban-ts-comment
		// @ts-ignore.  There are no types for this below
		const playerModule = await import("@brightcove/player-loader");
		const options = {
			...PLAYER_LOADER_OPTIONS,
			refNode: playerRef,
			videoId: curVid.id,
			accountId,
			playerId,
		};

		const vPlayer = await playerModule.default(options);
		setVjsPlayer(vPlayer.ref);

		//  inline prevents auto full screen for mobile
		vPlayer.ref.playsinline(true);
		// Set to the langauge passed from the request header. Unfortunately at time of authoring, neither dictionary for videojs seems complete, so if we have an initial complete, so we import the json and merge in everything for a maximal dict if we have it, otherwise just use what comes on the player from BC.
		if (props.videojsInitalDict) {
			const currentDictVidJs = vPlayer.ref.languages_[navigator.language];
			const completeDict = {
				...props.videojsInitalDict,
				...currentDictVidJs,
			};
			vPlayer.ref.languages_[navigator.language] = completeDict;
		}
		vPlayer.ref.language(navigator.language);

		// Incrementally update the URL to the current book/chapter/verse
		const throttleProgressUpdates = throttle(() => {
			const curVid = currentVid;
			const currentTime = vjsPlayer()?.currentTime();

			const newPathArr = [];
			const book = curVid.book;
			const currentBookChapter = curVid.chapter;
			if (book) newPathArr.push(book);
			if (currentBookChapter) newPathArr.push(currentBookChapter);
			// if chapters.. replaceState with the 1Jn.1.2 chapter, where the last number is the beginning of the current chapter
			if (curVid.chapterMarkers && currentTime) {
				const curChapter = curVid.chapterMarkers.find((marker) => {
					return (
						marker.chapterStart < currentTime && marker.chapterEnd > currentTime
					);
				});
				if (curChapter && curChapter.startVerse)
					newPathArr.push(curChapter.startVerse);
			}

			const newUrl = `${window.location.origin}/${newPathArr.join(".")}`;
			history.replaceState(null, "", newUrl);
		}, 1000);
		vPlayer.ref.on("progress", () => {
			throttleProgressUpdates();
			const currentTime = vjsPlayer()?.currentTime();
			currentTime && setVidProgress(currentTime);
		});

		// Handle taps on mobile for play/pause/fast forward
		const videoJsDomEl = vPlayer.ref.el();
		handleVideoJsTaps({
			el: videoJsDomEl,
			rightDoubleFxn(number) {
				const curTime = vjsPlayer()?.currentTime();
				if (!curTime) return;
				// the extra minus jumpAmount is to account for fact that min tap amoutn is 2 to diff btw double and single taps, so we still want to allow the smallest measure of jump back;
				const newTime = number * jumpAmount + curTime - jumpAmount;
				vjsPlayer()?.currentTime(newTime);
				setJumpingForwardAmount(null);
				videoJsDomEl.classList.remove("vjs-user-active");
			},
			leftDoubleFxn(number) {
				const curTime = vjsPlayer()?.currentTime();
				if (!curTime) return;

				const newTime = curTime - number * jumpAmount - jumpAmount;
				vjsPlayer()?.currentTime(newTime);
				setJumpingBackAmount(null);
				videoJsDomEl.classList.remove("vjs-user-active");
			},
			singleTapFxn() {
				const plyr = vjsPlayer();
				if (!plyr) return;
				if (plyr.paused()) {
					plyr.play();
				} else {
					plyr.pause();
				}
			},
			doubleTapUiClue(dir, tapsCount) {
				if (dir === "LEFT") {
					setJumpingBackAmount(tapsCount * jumpAmount - 5);
					setJumpingForwardAmount(null);
				} else if (dir === "RIGHT") {
					setJumpingBackAmount(null);
					setJumpingForwardAmount(tapsCount * jumpAmount - 5);
				}
			},
		});

		// On desktop, handle hotkeys for seek forward and backward
		vPlayer.ref.on("keydown", (e: KeyboardEvent) =>
			playerCustomHotKeys({
				e,
				vjsPlayer: vPlayer.ref,
				increment: jumpAmount,
				setJumpingBackAmount,
				setJumpingForwardAmount,
			}),
		);

		// setup. The reactivity in this case is the props, adn the props aren't going to change without routing to anotehr page.
		// eslint-disable-next-line solid/reactivity
		vPlayer.ref.one("loadedmetadata", async () => {
			// chapters not in the sense of book/chapter but in the sense of cue points in the video that mark verses
			handleChapters(curVid);
			// If we have a verse in Url (e.g.) Mrk.01.002, jump straight to that segment
			if (props.initialData.verseRouting) {
				const applicableChapter = await handleVerseProvidedInRouting(
					curVid,
					props.initialData.verseRouting,
				);
				if (applicableChapter) {
					vPlayer.ref.currentTime(applicableChapter.chapterStart);
				}
			}

			// Adjust speed if present in user preference cookie (just in case someone consistently wants to watch things fast)
			if (props.userPreferences?.playbackSpeed) {
				vjsPlayer()?.playbackRate(Number(props.userPreferences?.playbackSpeed));
			}
		});

		//handle the actual hovering to update the chapter spot
		// This section adds an indicator of the chapters markers on hover
		const seekBar = vPlayer.ref.controlBar.progressControl.seekBar;
		const handleProgressHover = debounce(handleProgressBarHover, 10);
		seekBar.on("mouseover", handleProgressHover);
		seekBar.el().addEventListener(
			"mouseover",
			() => {
				const currentToolTip = document.querySelector(
					".vjs-progress-control .vjs-mouse-display",
				) as Element;
				const seekBarEl = (
					<SeekBarChapterText text={currentChapLabel} />
				) as Node;
				currentToolTip.appendChild(seekBarEl);
			},
			{
				once: true,
			},
		);

		// Make forward/backward button work again since the chapters and book nav aren't full page reloads
		window.addEventListener("popstate", () => handlePopState());

		// For traditional mice, this manages buttons to handle left/right for when chapters buttons don't all fit on one page.
		createResizeObserver(chaptersContainerRef, (refRect) => {
			manageShowingChapterArrows(refRect, setShowChapSliderButtons);
		});
	});
	//=============== state setters / derived  =============
	return (
		<div class={`overflow-x-hidden ${CONTAINER} w-full sm:(rounded-lg)`}>
			<div
				ref={playerRefContainer}
				data-testid="video-player-container"
				data-title="VideoPlayer"
				class="w-full mx-auto aspect-video  relative  sm:(rounded-lg overflow-hidden)"
			>
				{/* Chapter Back */}
				<button
					data-testid="video-player-chapter-back"
					type="button"
					data-title="chapBack"
					class={`text-surface w-12 h-12 md:w-20 md:h-20 bg-gray-200/40 grid place-content-center rounded-full hover:( text-primary bg-primary/10) absolute left-4 top-1/2 -translate-y-1/2 z-30 ${
						(!trackAdjacentChap().prev || vjsPlayer()?.currentTime() === 0) &&
						"hidden"
					}`}
					onClick={() => {
						getAdjacentChap("PREV");
						jumpToNextChap("PREV");
					}}
				>
					<IconChapBack />
				</button>
				<div
					ref={playerRef}
					id="PLAYER"
					class="w-full h-full grid place-content-center"
				>
					<LoadingSpinner classNames="w-16 h-16 text-primary" />
				</div>
				<Show when={jumpingBackAmount()}>
					<div
						id="seekRippleBackward"
						class="absolute w-1/4  top-0 left-0 bottom-0  grid place-content-center rounded-[0%_100%_100%_0%_/_50%_50%_50%_50%] z-40  capitalize font-bold text-base pointer-events-none seekRipple"
					>
						{String(jumpingBackAmount())}
					</div>
				</Show>
				<Show when={jumpingForwardAmount()}>
					<div
						id="seekRippleForward"
						class="absolute w-1/4  top-0 right-0 bottom-0 seekRipple  grid place-content-center capitalize font-bold text-base z-40 rounded-[100%_0%_0%_100%_/_50%_50%_50%_50%] pointer-events-none"
					>
						{String(jumpingForwardAmount())}
					</div>
				</Show>

				<button
					data-testid="video-player-chapter-next"
					type="button"
					data-title="chapNext"
					class={`text-surface w-12 h-12 md:w-20 md:h-20 bg-gray-200/40 grid place-content-center rounded-full hover:( text-primary bg-primary/10) absolute right-4 top-1/2 -translate-y-1/2 z-30 ${
						(!trackAdjacentChap().next || vjsPlayer()?.currentTime() === 0) &&
						"hidden"
					}`}
					onClick={() => {
						getAdjacentChap("NEXT");
						jumpToNextChap("NEXT");
					}}
				>
					<IconChapNext />
				</button>
			</div>

			<div data-title="VideoSupplmental" class="py-2 px-2">
				<div data-title="videoControl" class="flex gap-2">
					{/* Chapter Forward */}
					<span class="inline-flex gap-1 items-center">
						<input
							data-testid="video-player-speed-control"
							type="range"
							class="speedRange appearance-none bg-transparent cursor-pointer w-60 "
							min=".25"
							max="5"
							step=".25"
							value={props.userPreferences?.playbackSpeed || "1"}
							onInput={(e) => {
								setPlayerSpeed(e.target.value);
							}}
							onChange={(e) => {
								handlePlayRateChange(e);
							}}
						/>
						<span class="inline-block h-5 w-5">
							<SpeedIcon />
						</span>
						<span class="inline-block ml-2">{playerSpeed()}</span>
					</span>
					{/* Speed Preference */}
					<div data-title="downloadCurrentVid" class="relative ml-auto">
						<form
							action={DOWNLOAD_SERVICE_WORK_URL}
							method="post"
							name={formName}
						>
							<input
								type="hidden"
								name="swPayload"
								value={JSON.stringify([currentMp4Sources()?.[0]])}
							/>
							<input
								type="hidden"
								name="swDownloadDevice"
								value={String("true")}
							/>
							<button type="submit" class="">
								<IconDownload classNames="hover:text-primary" />
							</button>
						</form>
					</div>
				</div>
				<div class="flex">
					<Show when={showChapSliderButtons()}>
						<button
							type="button"
							class="pr-3 text-2xl"
							onClick={() => {
								const chapterBtnTrack = document.querySelector(
									'[data-js="chapterButtonTrack"]',
								) as HTMLUListElement;
								if (chapterBtnTrack) {
									chapterBtnTrack.scrollLeft -= chapterBtnTrack.clientWidth;
								}
							}}
						>
							<IconMaterialSymbolsChevronLeft />
						</button>
					</Show>
					<div
						class="overflow-x-auto scrollbar-hide flex w-full"
						data-title="ChaptersNav"
						ref={chaptersContainerRef}
					>
						<ChapterList
							showChapSliderButtons={showChapSliderButtons}
							chapterButtonOnClick={(vid: IVidWithCustom) => {
								changePlayerSrc(vid);
							}}
							currentVid={currentVid}
						/>
					</div>
					<Show when={showChapSliderButtons()}>
						<button
							type="button"
							class="pl-3 text-2xl"
							onClick={() => {
								const chapterBtnTrack = document.querySelector(
									'[data-js="chapterButtonTrack"]',
								) as HTMLUListElement;
								if (chapterBtnTrack) {
									chapterBtnTrack.scrollLeft += chapterBtnTrack.clientWidth;
								}
							}}
						>
							<IconMaterialSymbolsChevronRight />
						</button>
					</Show>
				</div>
				<div
					data-title="BookAndPlaylistName"
					class={`${mobileHorizontalPadding} sm:(py-4)`}
				>
					<h1 class="font-bold">
						{" "}
						{normalizeBookName(
							currentVid?.localizedBookName || currentVid.book,
						)}
					</h1>
					<p>{props.playlistDisplayName}</p>
				</div>
			</div>
			<div
				data-testid="book-navigation-container"
				data-title="BookNav"
				class={`${mobileHorizontalPadding} py-2 bg-primary dark:bg-surface/05 text-base rounded-tr-xl rounded-tl-xl  scrollbar-hide min-h-200px`}
			>
				<h2 class="text-white dark:text-neutral-200 font-bold">
					{t("bibleSelection")}
				</h2>
				<p class="text-white dark:text-neutral-200">{t("chooseABook")}</p>
				<div class="relative h-full sm:h-auto ">
					<div
						style={{
							position: "absolute",
							inset: "0",
							"pointer-events": "none",
							height: "100%",
						}}
						class="y-scroll-gradient sm:(hidden)"
					/>
					<ul class="max-h-300px overflow-y-auto scrollbar-hide pt-8 pb-36 sm:(max-h-[50vh]) list-none">
						<For each={Object.entries(props.vids)}>
							{([key, book], idx) => {
								return (
									<li class="text-neutral-100 dark:text-neutral-200 py-1 w-full border-y border-base md:text-lg md:py-2">
										<button
											data-testid={`book-button-${key.toLowerCase()}`}
											type="button"
											onClick={() => {
												setNewBook(book);
												updateHistory(book[0], "PUSH");

												// see if need to resize buttons track
												const refRect =
													chaptersContainerRef?.getBoundingClientRect();
												manageShowingChapterArrows(
													refRect,
													setShowChapSliderButtons,
												);
											}}
											class={`inline-flex gap-2 items-center hover:(text-surface font-bold underline) ${
												currentVid.custom_fields?.book?.toUpperCase() ===
												key.toUpperCase()
													? "underline font-bold"
													: ""
											}`}
										>
											<span class="bg-base text-primary dark:text-primary rounded-full p-4 h-0 w-0 inline-grid place-content-center">
												{idx() + 1}
											</span>
											{normalizeBookName(
												book.find((b) => !!b.localizedBookName)
													?.localizedBookName || key,
											)}
										</button>
									</li>
								);
							}}
						</For>
					</ul>
				</div>
			</div>
		</div>
	);
}
</file>

</files>
