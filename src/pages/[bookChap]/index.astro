---
import Layout from "@layouts/Layout.astro";
import type { IVidWithCustom } from "@customTypes/types"
import {
  groupObjectsByKey,
  getUserPreferences,
getPreferredLangFromHeader,
mutateSortVidsArray,
// getPreferredLangFromHeader
} from "@utils";
import { Header } from "@components/Header";
import { AppWrapper } from "@components/AppWrapper";
import { getPlaylistData } from "@lib/routes";

// FIGURE OUT WHICH PLAYLIST TO LOAD BASED ON DOMAIN
import config from 'src/domainConfig.ts'
console.log("find me")
console.log({config})
let originToMatch = import.meta.env.PROD ? Astro.url.origin : "benin";
if (originToMatch.includes("dot-web.pages.dev")) {
  originToMatch = 'benin'
}
let matchingKey = Object.keys(config).find(key => originToMatch.toLowerCase().includes(key.toLowerCase()));
console.log({matchingKey})
if (!matchingKey || !config[matchingKey]) return Astro.redirect('404')
const configObj = config[matchingKey]
const playlist = configObj.playlist; 
const {bookChap} = Astro.params;
console.log({bookChap})
console.log("here")

if (!playlist) return Astro.redirect('404')

// Setup i18n
const preferredLocale = getPreferredLangFromHeader(Astro.request)
const initialDictModule = await import(`../../i18n/${preferredLocale}.ts`)
const initialDict = {
  [preferredLocale]: initialDictModule.default
}


// DATA FETCHING
let userPreferences = getUserPreferences(Astro)
let data = await getPlaylistData(Astro.url.origin, playlist)
if (!data) return Astro.redirect('404')

// DATA SHAPING
// type coercion here to add a few extra types below on this vids array. 
const vids = data.videos as IVidWithCustom[]
if (!vids || !vids.length) {
  return new Response(null, {
    status: 404
  })
}
const {sortedVids, filteredByMatchingReferenceId} = mutateSortVidsArray(vids)
const bucketized = groupObjectsByKey<IVidWithCustom, "book">(sortedVids, "book");
bucketized.other = filteredByMatchingReferenceId.notMatching

// ---ROUTING/INITIAL PROPS
//Regex = Start with any word or digit, then optional . separator, any number of optional digits (bc we want to match just a book e.g mat if given), and then another set of option digits.  Will match 
// Luk, Luk.2, LUK.2.7, 2jn.1, luk27.  Even the last is fine without the period since we'll just treat the two matches as book/chap
const bookChapRegex = /^([\d\w]+)(?:\.)?(\d+)?(?:\.)?(\d+)?/i
const routingParts = bookChap && bookChap.match(bookChapRegex);
const bookRouting = routingParts && routingParts?.[1]?.toUpperCase()
const chapRouting = routingParts && Number(routingParts?.[2])
const verseRouting = routingParts && routingParts?.[3] || undefined
const defaultBook = bookRouting && bucketized[bookRouting] ? 
      bucketized[bookRouting] :
      bucketized[Object.keys(bucketized)[0]];

const defChapIdx = defaultBook.findIndex(chap => Number(chap.chapter) == Number(chapRouting))
const defaultChap = defChapIdx > -1 ?  defaultBook[defChapIdx]: defaultBook[0]
const initialData = {vids: defaultBook, chap: defaultChap, verseRouting}
---

<Layout title="Experiments">
	<div class="">
		<Header client:idle prefersDark={userPreferences?.prefersDark}/>
  <div
    class="grid grid-rows-[auto_auto_1fr] overflow-y-auto"
  
  >
      <AppWrapper client:load userPreferences={userPreferences} initialData={initialData} playlist={playlist} vids={bucketized} locale={preferredLocale} initialDict={initialDict}/>
 </div> 
</div> 
</Layout>


<!-- <script define:vars={{ myPlayerUrl }} is:inline src={myPlayerUrl}></script> -->
